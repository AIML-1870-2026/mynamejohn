<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fractal Explorer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui, sans-serif;
            overflow: hidden;
            height: 100vh;
        }

        #mainCanvas {
            position: fixed;
            top: 0;
            left: 0;
            cursor: crosshair;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 20, 0.95);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            backdrop-filter: blur(10px);
            width: 300px;
            z-index: 100;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        .controls::-webkit-scrollbar { width: 6px; }
        .controls::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .controls::-webkit-scrollbar-thumb { background: rgba(100, 150, 255, 0.3); border-radius: 3px; }
        .controls h1 { font-size: 1.2em; margin-bottom: 3px; color: #7aa2ff; }
        .controls .subtitle { font-size: 0.7em; color: #666; margin-bottom: 12px; }

        .tabs { display: flex; gap: 4px; margin-bottom: 12px; }
        .tab {
            flex: 1; padding: 8px 4px; background: rgba(100, 150, 255, 0.1);
            border: 1px solid rgba(100, 150, 255, 0.2); color: #888;
            border-radius: 6px; cursor: pointer; font-size: 0.7em; transition: all 0.2s;
            text-align: center;
        }
        .tab:hover { background: rgba(100, 150, 255, 0.2); }
        .tab.active { background: rgba(100, 150, 255, 0.3); border-color: #7aa2ff; color: #c0d0ff; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }

        .control-group { margin-bottom: 10px; }
        .control-group label { display: block; font-size: 0.75em; margin-bottom: 3px; color: #aaa; }
        .control-group input[type="range"] {
            width: 100%; height: 6px; -webkit-appearance: none;
            background: rgba(100, 150, 255, 0.2); border-radius: 3px; outline: none;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 14px; height: 14px;
            background: #7aa2ff; border-radius: 50%; cursor: pointer;
        }
        .control-group select {
            width: 100%; padding: 6px; background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(100, 150, 255, 0.3); color: #c0d0ff;
            border-radius: 6px; font-size: 0.8em; cursor: pointer;
        }
        .value-display { font-size: 0.7em; color: #7aa2ff; float: right; }
        .divider { height: 1px; background: rgba(100, 150, 255, 0.2); margin: 10px 0; }
        .section-title { font-size: 0.8em; color: #7aa2ff; margin-bottom: 6px; }

        .presets { display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px; margin-bottom: 10px; }
        .preset-btn {
            padding: 5px 4px; background: rgba(100, 150, 255, 0.15);
            border: 1px solid rgba(100, 150, 255, 0.3); color: #c0d0ff;
            border-radius: 4px; cursor: pointer; font-size: 0.65em; transition: all 0.2s;
        }
        .preset-btn:hover { background: rgba(100, 150, 255, 0.3); }
        .preset-btn.active { background: rgba(100, 150, 255, 0.4); border-color: #7aa2ff; }

        .color-schemes { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin-bottom: 10px; }
        .color-btn {
            padding: 6px 4px; border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 4px; cursor: pointer; font-size: 0.6em; transition: all 0.2s;
            background: rgba(20,20,40,0.5); color: #c0d0ff; text-align: center;
        }
        .color-btn:hover { border-color: #7aa2ff; }
        .color-btn.active { border-color: #7aa2ff; box-shadow: 0 0 8px rgba(100, 150, 255, 0.3); }

        .btn-row { display: flex; gap: 6px; margin-bottom: 8px; }
        .action-btn {
            flex: 1; padding: 7px; background: rgba(100, 150, 255, 0.2);
            border: 1px solid rgba(100, 150, 255, 0.4); color: #c0d0ff;
            border-radius: 6px; cursor: pointer; font-size: 0.75em; transition: all 0.2s;
        }
        .action-btn:hover { background: rgba(100, 150, 255, 0.35); }
        .action-btn.active { background: rgba(100, 200, 100, 0.3); border-color: #7aff7a; }

        #mandelbrotPreview {
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 6px; cursor: crosshair; background: #000;
            display: block; margin: 0 auto 6px;
        }
        .preview-label { font-size: 0.65em; color: #555; text-align: center; margin-bottom: 6px; }
        .c-value { font-size: 0.75em; color: #7aa2ff; text-align: center; font-family: monospace; margin-bottom: 8px; }

        /* Gradient editor */
        .gradient-editor { margin-bottom: 10px; }
        .gradient-bar {
            height: 24px; border-radius: 4px; margin-bottom: 6px;
            border: 1px solid rgba(100, 150, 255, 0.3); position: relative; cursor: pointer;
        }
        .gradient-stop {
            position: absolute; width: 12px; height: 12px; border-radius: 50%;
            border: 2px solid white; top: 50%; transform: translate(-50%, -50%);
            cursor: grab; box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }
        .gradient-stop.selected { border-color: #7aa2ff; }
        .gradient-controls { display: flex; gap: 6px; align-items: center; }
        .gradient-controls input[type="color"] {
            width: 40px; height: 28px; border: none; border-radius: 4px; cursor: pointer;
        }

        /* Info panel */
        .info-panel {
            position: fixed; top: 20px; right: 20px;
            background: rgba(10, 10, 20, 0.95); padding: 15px;
            border-radius: 12px; border: 1px solid rgba(100, 150, 255, 0.3);
            backdrop-filter: blur(10px); width: 280px; z-index: 100;
            font-size: 0.75em; display: none;
        }
        .info-panel.visible { display: block; }
        .info-panel h3 { color: #7aa2ff; margin-bottom: 8px; font-size: 1.1em; }
        .info-panel p { color: #aaa; margin-bottom: 8px; line-height: 1.5; }
        .info-panel .formula {
            font-family: monospace; color: #c0d0ff;
            background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px;
            text-align: center; margin: 8px 0;
        }

        /* Education mode */
        #iterCanvas {
            position: fixed; bottom: 20px; right: 20px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            border-radius: 8px; background: rgba(0,0,0,0.9);
            display: none; cursor: crosshair;
        }
        #iterCanvas.visible { display: block; }
        .iter-label {
            position: fixed; bottom: 230px; right: 20px;
            font-size: 0.7em; color: #666; display: none;
        }
        .iter-label.visible { display: block; }

        .stats {
            position: fixed; bottom: 20px; left: 20px;
            font-size: 0.7em; color: #555; z-index: 50;
        }
        .help {
            position: fixed; bottom: 40px; left: 20px;
            font-size: 0.65em; color: #444;
        }

        /* Split view */
        .split-divider {
            position: fixed; top: 0; width: 4px; height: 100%;
            background: rgba(100, 150, 255, 0.5); cursor: ew-resize;
            display: none; z-index: 200;
        }
        .split-divider.visible { display: block; }

        /* High-res modal */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; z-index: 1000;
            align-items: center; justify-content: center;
        }
        .modal.visible { display: flex; }
        .modal-content {
            background: rgba(20, 20, 40, 0.98); padding: 25px;
            border-radius: 12px; border: 1px solid rgba(100, 150, 255, 0.3);
            min-width: 300px;
        }
        .modal-content h3 { color: #7aa2ff; margin-bottom: 15px; }
        .modal-content .btn-row { margin-top: 15px; }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <canvas id="iterCanvas" width="200" height="200"></canvas>
    <div class="iter-label">Iteration Path Visualizer<br>Click on fractal to trace point</div>
    <div class="split-divider" id="splitDivider"></div>

    <div class="controls">
        <h1>Fractal Explorer</h1>
        <div class="subtitle">Julia Sets, Mandelbrot & Burning Ship</div>

        <div class="tabs">
            <div class="tab active" data-tab="main">Main</div>
            <div class="tab" data-tab="colors">Colors</div>
            <div class="tab" data-tab="animate">Animate</div>
            <div class="tab" data-tab="export">Export</div>
        </div>

        <!-- Main Tab -->
        <div class="tab-content active" id="tab-main">
            <div class="control-group">
                <label>Fractal Type</label>
                <select id="fractalType">
                    <option value="julia">Julia Set</option>
                    <option value="mandelbrot">Mandelbrot Set</option>
                    <option value="burningShip">Burning Ship</option>
                    <option value="burningJulia">Burning Ship Julia</option>
                </select>
            </div>

            <div class="divider"></div>

            <div id="juliaControls">
                <div class="section-title">Select c from Mandelbrot</div>
                <canvas id="mandelbrotPreview" width="268" height="180"></canvas>
                <div class="preview-label">Click to choose c parameter</div>
                <div class="c-value" id="cValue">c = -0.7 + 0.27i</div>

                <div class="section-title">Julia Set Presets</div>
                <div class="presets">
                    <button class="preset-btn" data-c="-0.7,0.27015">Dendrite</button>
                    <button class="preset-btn" data-c="-0.8,0.156">Spiral</button>
                    <button class="preset-btn" data-c="-0.4,0.6">Dragon</button>
                    <button class="preset-btn" data-c="0.285,0.01">Galaxies</button>
                    <button class="preset-btn active" data-c="-0.835,-0.2321">Lightning</button>
                    <button class="preset-btn" data-c="-0.70176,-0.3842">Seahorse</button>
                    <button class="preset-btn" data-c="0.285,0.53">Snowflake</button>
                    <button class="preset-btn" data-c="-0.75,0.11">San Marco</button>
                    <button class="preset-btn" data-c="-0.1,0.651">Rabbit</button>
                    <button class="preset-btn" data-c="-1.476,0">Cauliflower</button>
                    <button class="preset-btn" data-c="0,-1">Basilica</button>
                    <button class="preset-btn" data-c="-0.39054,-0.58679">Vortex</button>
                </div>

                <div class="divider"></div>

                <div class="control-group">
                    <label>Real(c) <span class="value-display" id="cRealValue">-0.835</span></label>
                    <input type="range" id="cReal" min="-2" max="2" step="0.001" value="-0.835">
                </div>
                <div class="control-group">
                    <label>Imag(c) <span class="value-display" id="cImagValue">-0.2321</span></label>
                    <input type="range" id="cImag" min="-2" max="2" step="0.001" value="-0.2321">
                </div>
            </div>

            <div class="divider"></div>

            <div class="control-group">
                <label>Max Iterations <span class="value-display" id="iterValue">300</span></label>
                <input type="range" id="maxIter" min="50" max="2000" step="10" value="300">
            </div>

            <div class="control-group">
                <label>Escape Radius <span class="value-display" id="escapeValue">4</span></label>
                <input type="range" id="escapeRadius" min="2" max="50" step="1" value="4">
            </div>

            <div class="divider"></div>

            <div class="btn-row">
                <button class="action-btn" id="resetZoom">Reset View</button>
                <button class="action-btn" id="splitViewBtn">Split View</button>
            </div>
            <div class="btn-row">
                <button class="action-btn" id="infoBtn">Info Panel</button>
                <button class="action-btn" id="eduBtn">Education</button>
            </div>
        </div>

        <!-- Colors Tab -->
        <div class="tab-content" id="tab-colors">
            <div class="section-title">Color Scheme</div>
            <div class="color-schemes">
                <button class="color-btn active" data-scheme="electric">Electric</button>
                <button class="color-btn" data-scheme="fire">Fire</button>
                <button class="color-btn" data-scheme="ocean">Ocean</button>
                <button class="color-btn" data-scheme="rainbow">Rainbow</button>
                <button class="color-btn" data-scheme="midnight">Midnight</button>
                <button class="color-btn" data-scheme="gold">Gold</button>
                <button class="color-btn" data-scheme="neon">Neon</button>
                <button class="color-btn" data-scheme="plasma">Plasma</button>
                <button class="color-btn" data-scheme="ice">Ice</button>
                <button class="color-btn" data-scheme="forest">Forest</button>
                <button class="color-btn" data-scheme="sunset">Sunset</button>
                <button class="color-btn" data-scheme="grayscale">Gray</button>
            </div>

            <div class="divider"></div>

            <div class="section-title">Custom Gradient Editor</div>
            <div class="gradient-editor">
                <div class="gradient-bar" id="gradientBar"></div>
                <div class="gradient-controls">
                    <input type="color" id="stopColor" value="#7aa2ff">
                    <button class="action-btn" id="addStop" style="flex:0.5;">Add</button>
                    <button class="action-btn" id="removeStop" style="flex:0.5;">Remove</button>
                    <button class="action-btn" id="applyGradient" style="flex:0.7;">Apply</button>
                </div>
            </div>

            <div class="divider"></div>

            <div class="control-group">
                <label>Color Cycling Speed <span class="value-display" id="cycleSpeedValue">0</span></label>
                <input type="range" id="cycleSpeed" min="0" max="5" step="0.1" value="0">
            </div>

            <div class="control-group">
                <label>Interior Color</label>
                <select id="interiorColor">
                    <option value="black">Black</option>
                    <option value="white">White</option>
                    <option value="gradient">Gradient End</option>
                </select>
            </div>
        </div>

        <!-- Animate Tab -->
        <div class="tab-content" id="tab-animate">
            <div class="section-title">Parameter Morphing</div>
            <div class="control-group">
                <label>Animation Path</label>
                <select id="animPath">
                    <option value="circle">Circle</option>
                    <option value="cardioid">Cardioid Edge</option>
                    <option value="figure8">Figure 8</option>
                    <option value="spiral">Spiral In</option>
                    <option value="random">Random Walk</option>
                    <option value="presets">Morph Presets</option>
                </select>
            </div>

            <div class="control-group">
                <label>Animation Speed <span class="value-display" id="animSpeedValue">1.0</span></label>
                <input type="range" id="animSpeed" min="0.1" max="5" step="0.1" value="1">
            </div>

            <div class="btn-row">
                <button class="action-btn" id="morphBtn">Start Morphing</button>
                <button class="action-btn" id="zoomAnimBtn">Auto Zoom</button>
            </div>

            <div class="divider"></div>

            <div class="section-title">Zoom Animation</div>
            <div class="control-group">
                <label>Zoom Speed <span class="value-display" id="zoomSpeedValue">1.0</span></label>
                <input type="range" id="zoomSpeed" min="0.1" max="3" step="0.1" value="1">
            </div>

            <div class="control-group">
                <label>Zoom Target</label>
                <select id="zoomTarget">
                    <option value="center">Current Center</option>
                    <option value="seahorse">Seahorse Valley</option>
                    <option value="elephant">Elephant Valley</option>
                    <option value="spiral">Spiral Point</option>
                </select>
            </div>
        </div>

        <!-- Export Tab -->
        <div class="tab-content" id="tab-export">
            <div class="section-title">Quick Save</div>
            <div class="btn-row">
                <button class="action-btn" id="saveBtn">Save Image</button>
            </div>

            <div class="divider"></div>

            <div class="section-title">High Resolution Export</div>
            <div class="control-group">
                <label>Resolution</label>
                <select id="exportRes">
                    <option value="1920,1080">1920 x 1080 (HD)</option>
                    <option value="2560,1440">2560 x 1440 (2K)</option>
                    <option value="3840,2160">3840 x 2160 (4K)</option>
                    <option value="5120,2880">5120 x 2880 (5K)</option>
                    <option value="7680,4320">7680 x 4320 (8K)</option>
                </select>
            </div>

            <div class="control-group">
                <label>Supersampling</label>
                <select id="exportSS">
                    <option value="1">None</option>
                    <option value="2">2x (Smoother)</option>
                    <option value="4">4x (Best Quality)</option>
                </select>
            </div>

            <div class="btn-row">
                <button class="action-btn" id="hiResBtn">Render High-Res</button>
            </div>

            <div id="renderProgress" style="display:none; margin-top:10px;">
                <div style="background:rgba(100,150,255,0.2); border-radius:4px; height:8px; overflow:hidden;">
                    <div id="progressBar" style="background:#7aa2ff; height:100%; width:0%; transition:width 0.1s;"></div>
                </div>
                <div style="font-size:0.7em; color:#666; margin-top:4px; text-align:center;" id="progressText">0%</div>
            </div>
        </div>
    </div>

    <!-- Info Panel -->
    <div class="info-panel" id="infoPanel">
        <h3 id="infoTitle">Julia Set</h3>
        <div class="formula" id="infoFormula">z → z² + c</div>
        <p id="infoText">
            The Julia set is the boundary between points that escape to infinity
            and points that remain bounded under iteration of f(z) = z² + c.
            Each value of c produces a different Julia set. Connected Julia sets
            occur when c is in the Mandelbrot set.
        </p>
        <div class="divider"></div>
        <p style="font-size:0.9em; color:#7aa2ff;">Current Parameters:</p>
        <p id="infoParams">c = -0.835 - 0.2321i<br>Zoom: 1x<br>Iterations: 300</p>
    </div>

    <!-- High-res Modal -->
    <div class="modal" id="hiResModal">
        <div class="modal-content">
            <h3>High Resolution Export</h3>
            <p style="color:#aaa; font-size:0.85em;">Rendering in progress...</p>
            <div style="margin-top:15px;">
                <div style="background:rgba(100,150,255,0.2); border-radius:4px; height:10px; overflow:hidden;">
                    <div id="modalProgress" style="background:#7aa2ff; height:100%; width:0%;"></div>
                </div>
                <div style="font-size:0.75em; color:#666; margin-top:6px; text-align:center;" id="modalProgressText">Initializing...</div>
            </div>
            <div class="btn-row">
                <button class="action-btn" id="cancelRender">Cancel</button>
            </div>
        </div>
    </div>

    <div class="stats">
        <span id="fps">0 FPS</span> |
        <span id="zoomLevel">Zoom: 1x</span> |
        <span id="coords">0, 0</span>
    </div>

    <div class="help">
        Scroll: Zoom | Drag: Pan | Double-click: Zoom in | Right-click: Trace iteration
    </div>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const ctx = mainCanvas.getContext('2d');
        const iterCanvas = document.getElementById('iterCanvas');
        const iterCtx = iterCanvas.getContext('2d');
        const mandelbrotCanvas = document.getElementById('mandelbrotPreview');
        const mandelbrotCtx = mandelbrotCanvas.getContext('2d');

        // State
        let state = {
            fractalType: 'julia',
            cReal: -0.835,
            cImag: -0.2321,
            maxIter: 300,
            escapeRadius: 4,
            colorScheme: 'electric',

            centerX: 0,
            centerY: 0,
            zoom: 1,

            // Animation
            morphing: false,
            zoomAnimating: false,
            animSpeed: 1,
            zoomSpeed: 1,
            animPath: 'circle',
            animTime: 0,

            // Color cycling
            cycleSpeed: 0,
            cycleOffset: 0,
            interiorColor: 'black',

            // UI
            splitView: false,
            splitPos: 0.5,
            showInfo: false,
            showEducation: false,

            // Custom gradient
            customGradient: [
                { pos: 0, color: '#000033' },
                { pos: 0.25, color: '#0066ff' },
                { pos: 0.5, color: '#ff00ff' },
                { pos: 0.75, color: '#ffff00' },
                { pos: 1, color: '#ffffff' }
            ],
            selectedStop: null
        };

        // Preset data
        const juliaPresets = {
            'Dendrite': [-0.7, 0.27015],
            'Spiral': [-0.8, 0.156],
            'Dragon': [-0.4, 0.6],
            'Galaxies': [0.285, 0.01],
            'Lightning': [-0.835, -0.2321],
            'Seahorse': [-0.70176, -0.3842],
            'Snowflake': [0.285, 0.53],
            'San Marco': [-0.75, 0.11],
            'Rabbit': [-0.1, 0.651],
            'Cauliflower': [-1.476, 0],
            'Basilica': [0, -1],
            'Vortex': [-0.39054, -0.58679]
        };

        const zoomTargets = {
            center: { x: 0, y: 0 },
            seahorse: { x: -0.743643887037151, y: 0.131825904205330 },
            elephant: { x: 0.281717921930775, y: 0.5771052841488505 },
            spiral: { x: -0.761574, y: -0.0847596 }
        };

        // Color schemes
        const colorSchemes = {
            electric: t => {
                const r = Math.floor(9 * (1-t) * t * t * t * 255);
                const g = Math.floor(15 * (1-t) * (1-t) * t * t * 255);
                const b = Math.floor(8.5 * (1-t) * (1-t) * (1-t) * t * 255 + t * 200);
                return [r, g, b];
            },
            fire: t => [
                Math.floor(Math.min(255, t * 3 * 255)),
                Math.floor(Math.max(0, Math.min(255, (t - 0.33) * 3 * 255))),
                Math.floor(Math.max(0, Math.min(255, (t - 0.67) * 3 * 255)))
            ],
            ocean: t => [
                Math.floor(t * 30),
                Math.floor(30 + t * 150),
                Math.floor(80 + t * 175)
            ],
            rainbow: t => hslToRgb(t * 360, 100, 50),
            midnight: t => [
                Math.floor(10 + t * 60),
                Math.floor(5 + t * 40),
                Math.floor(30 + t * 150)
            ],
            gold: t => [
                Math.floor(40 + t * 215),
                Math.floor(25 + t * 180),
                Math.floor(t * 60)
            ],
            neon: t => {
                const phase = t * Math.PI * 2;
                return [
                    Math.floor(127 + 128 * Math.sin(phase)),
                    Math.floor(127 + 128 * Math.sin(phase + 2.094)),
                    Math.floor(127 + 128 * Math.sin(phase + 4.189))
                ];
            },
            plasma: t => [
                Math.floor(Math.sin(t * Math.PI) * 255),
                Math.floor(Math.sin(t * Math.PI * 0.5) * 128),
                Math.floor(128 + Math.cos(t * Math.PI) * 127)
            ],
            ice: t => [
                Math.floor(200 + t * 55),
                Math.floor(220 + t * 35),
                Math.floor(255)
            ],
            forest: t => [
                Math.floor(20 + t * 60),
                Math.floor(50 + t * 150),
                Math.floor(30 + t * 80)
            ],
            sunset: t => [
                Math.floor(50 + t * 205),
                Math.floor(20 + t * 100),
                Math.floor(80 + t * 100)
            ],
            grayscale: t => {
                const v = Math.floor(t * 255);
                return [v, v, v];
            },
            custom: t => interpolateGradient(t, state.customGradient)
        };

        function hslToRgb(h, s, l) {
            s /= 100; l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return [Math.floor((r + m) * 255), Math.floor((g + m) * 255), Math.floor((b + m) * 255)];
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        function interpolateGradient(t, stops) {
            t = Math.max(0, Math.min(1, t));
            for (let i = 0; i < stops.length - 1; i++) {
                if (t >= stops[i].pos && t <= stops[i + 1].pos) {
                    const localT = (t - stops[i].pos) / (stops[i + 1].pos - stops[i].pos);
                    const c1 = hexToRgb(stops[i].color);
                    const c2 = hexToRgb(stops[i + 1].color);
                    return [
                        Math.floor(c1[0] + (c2[0] - c1[0]) * localT),
                        Math.floor(c1[1] + (c2[1] - c1[1]) * localT),
                        Math.floor(c1[2] + (c2[2] - c1[2]) * localT)
                    ];
                }
            }
            return hexToRgb(stops[stops.length - 1].color);
        }

        let imageData, pixels;
        let needsRender = true;
        let renderCancelled = false;

        function init() {
            mainCanvas.width = window.innerWidth;
            mainCanvas.height = window.innerHeight;
            imageData = ctx.createImageData(mainCanvas.width, mainCanvas.height);
            pixels = imageData.data;
            needsRender = true;
            renderMandelbrotPreview();
            updateGradientBar();
        }

        function computeFractal(px, py, width, height, viewCenterX, viewCenterY, viewZoom) {
            const aspectRatio = width / height;
            const scale = 3 / viewZoom;
            const xMin = viewCenterX - scale * aspectRatio / 2;
            const yMin = viewCenterY - scale / 2;
            const xRange = scale * aspectRatio;
            const yRange = scale;

            const x0 = xMin + (px / width) * xRange;
            const y0 = yMin + (py / height) * yRange;

            let zReal, zImag, cReal, cImag;

            if (state.fractalType === 'julia' || state.fractalType === 'burningJulia') {
                zReal = x0;
                zImag = y0;
                cReal = state.cReal;
                cImag = state.cImag;
            } else {
                zReal = 0;
                zImag = 0;
                cReal = x0;
                cImag = y0;
            }

            const maxIter = state.maxIter;
            const escapeRadiusSq = state.escapeRadius * state.escapeRadius;
            const burning = state.fractalType === 'burningShip' || state.fractalType === 'burningJulia';

            let iter = 0;
            let zReal2 = zReal * zReal;
            let zImag2 = zImag * zImag;

            while (zReal2 + zImag2 < escapeRadiusSq && iter < maxIter) {
                if (burning) {
                    zImag = Math.abs(2 * zReal * zImag) + cImag;
                    zReal = zReal2 - zImag2 + cReal;
                } else {
                    zImag = 2 * zReal * zImag + cImag;
                    zReal = zReal2 - zImag2 + cReal;
                }
                zReal2 = zReal * zReal;
                zImag2 = zImag * zImag;
                iter++;
            }

            return { iter, zReal2, zImag2 };
        }

        function renderFractal() {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const colorFn = colorSchemes[state.colorScheme];
            const maxIter = state.maxIter;
            const cycleOffset = state.cycleOffset;

            const startX = state.splitView ? Math.floor(width * state.splitPos) : 0;
            const renderWidth = state.splitView ? width - startX : width;

            // Render left side (Mandelbrot) if split view
            if (state.splitView) {
                const savedType = state.fractalType;
                state.fractalType = 'mandelbrot';
                for (let py = 0; py < height; py++) {
                    for (let px = 0; px < startX; px++) {
                        const { iter, zReal2, zImag2 } = computeFractal(
                            px / state.splitPos, py, width, height,
                            -0.5, 0, 1
                        );
                        const idx = (py * width + px) * 4;
                        colorPixel(idx, iter, zReal2, zImag2, maxIter, colorFn, cycleOffset);
                    }
                }
                state.fractalType = savedType;
            }

            // Render main fractal
            for (let py = 0; py < height; py++) {
                for (let px = startX; px < width; px++) {
                    const { iter, zReal2, zImag2 } = computeFractal(
                        px - startX, py, renderWidth, height,
                        state.centerX, state.centerY, state.zoom
                    );
                    const idx = (py * width + px) * 4;
                    colorPixel(idx, iter, zReal2, zImag2, maxIter, colorFn, cycleOffset);
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw split divider
            if (state.splitView) {
                ctx.strokeStyle = 'rgba(100, 150, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(width * state.splitPos, 0);
                ctx.lineTo(width * state.splitPos, height);
                ctx.stroke();
            }
        }

        function colorPixel(idx, iter, zReal2, zImag2, maxIter, colorFn, cycleOffset) {
            if (iter === maxIter) {
                if (state.interiorColor === 'black') {
                    pixels[idx] = 0;
                    pixels[idx + 1] = 0;
                    pixels[idx + 2] = 0;
                } else if (state.interiorColor === 'white') {
                    pixels[idx] = 255;
                    pixels[idx + 1] = 255;
                    pixels[idx + 2] = 255;
                } else {
                    const [r, g, b] = colorFn(1);
                    pixels[idx] = r;
                    pixels[idx + 1] = g;
                    pixels[idx + 2] = b;
                }
            } else {
                const smooth = iter + 1 - Math.log2(Math.log(zReal2 + zImag2) / 2);
                let t = (smooth / maxIter + cycleOffset) % 1;
                if (t < 0) t += 1;
                const [r, g, b] = colorFn(t);
                pixels[idx] = r;
                pixels[idx + 1] = g;
                pixels[idx + 2] = b;
            }
            pixels[idx + 3] = 255;
        }

        function renderMandelbrotPreview() {
            const width = mandelbrotCanvas.width;
            const height = mandelbrotCanvas.height;
            const imgData = mandelbrotCtx.createImageData(width, height);
            const data = imgData.data;

            const xMin = -2.5, xMax = 1;
            const yMin = -1.2, yMax = 1.2;
            const maxIter = 80;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const cReal = xMin + (px / width) * (xMax - xMin);
                    const cImag = yMin + (py / height) * (yMax - yMin);

                    let zReal = 0, zImag = 0, iter = 0;
                    while (zReal * zReal + zImag * zImag < 4 && iter < maxIter) {
                        const temp = zReal * zReal - zImag * zImag + cReal;
                        zImag = 2 * zReal * zImag + cImag;
                        zReal = temp;
                        iter++;
                    }

                    const idx = (py * width + px) * 4;
                    if (iter === maxIter) {
                        data[idx] = 15; data[idx + 1] = 15; data[idx + 2] = 30;
                    } else {
                        const t = iter / maxIter;
                        data[idx] = Math.floor(30 + t * 80);
                        data[idx + 1] = Math.floor(40 + t * 100);
                        data[idx + 2] = Math.floor(70 + t * 150);
                    }
                    data[idx + 3] = 255;
                }
            }

            mandelbrotCtx.putImageData(imgData, 0, 0);

            // Draw c marker
            const cx = ((state.cReal - xMin) / (xMax - xMin)) * width;
            const cy = ((state.cImag - yMin) / (yMax - yMin)) * height;

            mandelbrotCtx.strokeStyle = '#ff4444';
            mandelbrotCtx.lineWidth = 2;
            mandelbrotCtx.beginPath();
            mandelbrotCtx.arc(cx, cy, 6, 0, Math.PI * 2);
            mandelbrotCtx.stroke();
            mandelbrotCtx.fillStyle = '#ff4444';
            mandelbrotCtx.beginPath();
            mandelbrotCtx.arc(cx, cy, 2, 0, Math.PI * 2);
            mandelbrotCtx.fill();
        }

        function renderIterationPath(clickX, clickY) {
            if (!state.showEducation) return;

            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const aspectRatio = width / height;
            const scale = 3 / state.zoom;

            const x0 = state.centerX + (clickX / width - 0.5) * scale * aspectRatio;
            const y0 = state.centerY + (clickY / height - 0.5) * scale;

            let zReal, zImag, cReal, cImag;
            if (state.fractalType === 'julia' || state.fractalType === 'burningJulia') {
                zReal = x0; zImag = y0;
                cReal = state.cReal; cImag = state.cImag;
            } else {
                zReal = 0; zImag = 0;
                cReal = x0; cImag = y0;
            }

            const burning = state.fractalType === 'burningShip' || state.fractalType === 'burningJulia';
            const points = [[zReal, zImag]];

            for (let i = 0; i < Math.min(50, state.maxIter); i++) {
                if (zReal * zReal + zImag * zImag > 100) break;
                if (burning) {
                    const newImag = Math.abs(2 * zReal * zImag) + cImag;
                    zReal = zReal * zReal - zImag * zImag + cReal;
                    zImag = newImag;
                } else {
                    const newImag = 2 * zReal * zImag + cImag;
                    zReal = zReal * zReal - zImag * zImag + cReal;
                    zImag = newImag;
                }
                points.push([zReal, zImag]);
            }

            // Draw on iteration canvas
            iterCtx.fillStyle = '#0a0a15';
            iterCtx.fillRect(0, 0, 200, 200);

            // Find bounds
            let minX = -2, maxX = 2, minY = -2, maxY = 2;
            points.forEach(p => {
                minX = Math.min(minX, p[0]);
                maxX = Math.max(maxX, p[0]);
                minY = Math.min(minY, p[1]);
                maxY = Math.max(maxY, p[1]);
            });
            const range = Math.max(maxX - minX, maxY - minY) * 1.2;
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            // Draw axes
            iterCtx.strokeStyle = '#333';
            iterCtx.lineWidth = 1;
            const axisX = 100 + (0 - cx) / range * 180;
            const axisY = 100 + (0 - cy) / range * 180;
            iterCtx.beginPath();
            iterCtx.moveTo(axisX, 0); iterCtx.lineTo(axisX, 200);
            iterCtx.moveTo(0, axisY); iterCtx.lineTo(200, axisY);
            iterCtx.stroke();

            // Draw path
            iterCtx.strokeStyle = '#7aa2ff';
            iterCtx.lineWidth = 1.5;
            iterCtx.beginPath();
            points.forEach((p, i) => {
                const px = 100 + (p[0] - cx) / range * 180;
                const py = 100 + (p[1] - cy) / range * 180;
                if (i === 0) iterCtx.moveTo(px, py);
                else iterCtx.lineTo(px, py);
            });
            iterCtx.stroke();

            // Draw points
            points.forEach((p, i) => {
                const px = 100 + (p[0] - cx) / range * 180;
                const py = 100 + (p[1] - cy) / range * 180;
                iterCtx.fillStyle = i === 0 ? '#00ff00' : (i === points.length - 1 ? '#ff4444' : '#7aa2ff');
                iterCtx.beginPath();
                iterCtx.arc(px, py, i === 0 || i === points.length - 1 ? 4 : 2, 0, Math.PI * 2);
                iterCtx.fill();
            });

            // Labels
            iterCtx.fillStyle = '#666';
            iterCtx.font = '10px sans-serif';
            iterCtx.fillText(`z₀ = (${x0.toFixed(3)}, ${y0.toFixed(3)})`, 5, 190);
            iterCtx.fillText(`${points.length} iterations`, 5, 12);
        }

        function updateCDisplay() {
            const sign = state.cImag >= 0 ? '+' : '-';
            document.getElementById('cValue').textContent =
                `c = ${state.cReal.toFixed(4)} ${sign} ${Math.abs(state.cImag).toFixed(4)}i`;
            document.getElementById('cReal').value = state.cReal;
            document.getElementById('cImag').value = state.cImag;
            document.getElementById('cRealValue').textContent = state.cReal.toFixed(4);
            document.getElementById('cImagValue').textContent = state.cImag.toFixed(4);
        }

        function updateInfoPanel() {
            const titles = {
                julia: 'Julia Set',
                mandelbrot: 'Mandelbrot Set',
                burningShip: 'Burning Ship',
                burningJulia: 'Burning Ship Julia'
            };
            const formulas = {
                julia: 'z → z² + c',
                mandelbrot: 'z → z² + c (c varies)',
                burningShip: 'z → (|Re(z)| + i|Im(z)|)² + c',
                burningJulia: 'z → (|Re(z)| + i|Im(z)|)² + c'
            };
            const descriptions = {
                julia: 'The Julia set is the boundary between points that escape to infinity and points that remain bounded. Each value of c produces a unique fractal. Connected Julia sets occur when c lies within the Mandelbrot set.',
                mandelbrot: 'The Mandelbrot set is the set of complex numbers c for which the iteration z → z² + c (starting from z=0) does not escape to infinity. It serves as a "map" of all Julia sets.',
                burningShip: 'The Burning Ship fractal uses absolute values before squaring, creating a distinctive "ship" shape. It has similar self-similarity to the Mandelbrot set but with a more chaotic appearance.',
                burningJulia: 'The Burning Ship Julia set applies the Burning Ship iteration rule with a fixed c parameter. It creates dramatic, flame-like patterns.'
            };

            document.getElementById('infoTitle').textContent = titles[state.fractalType];
            document.getElementById('infoFormula').textContent = formulas[state.fractalType];
            document.getElementById('infoText').textContent = descriptions[state.fractalType];

            let params = '';
            if (state.fractalType === 'julia' || state.fractalType === 'burningJulia') {
                const sign = state.cImag >= 0 ? '+' : '-';
                params += `c = ${state.cReal.toFixed(4)} ${sign} ${Math.abs(state.cImag).toFixed(4)}i<br>`;
            }
            params += `Zoom: ${state.zoom.toFixed(2)}x<br>`;
            params += `Iterations: ${state.maxIter}`;
            document.getElementById('infoParams').innerHTML = params;
        }

        function updateGradientBar() {
            const bar = document.getElementById('gradientBar');
            const stops = state.customGradient.map(s => `${s.color} ${s.pos * 100}%`).join(', ');
            bar.style.background = `linear-gradient(to right, ${stops})`;

            // Remove old stop handles
            bar.querySelectorAll('.gradient-stop').forEach(el => el.remove());

            // Add stop handles
            state.customGradient.forEach((stop, i) => {
                const handle = document.createElement('div');
                handle.className = 'gradient-stop' + (state.selectedStop === i ? ' selected' : '');
                handle.style.left = (stop.pos * 100) + '%';
                handle.style.background = stop.color;
                handle.dataset.index = i;
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    state.selectedStop = i;
                    document.getElementById('stopColor').value = stop.color;
                    updateGradientBar();
                });
                bar.appendChild(handle);
            });
        }

        // Animation paths for morphing
        function getAnimationC(t, path) {
            switch (path) {
                case 'circle':
                    return [0.7885 * Math.cos(t), 0.7885 * Math.sin(t)];
                case 'cardioid':
                    const angle = t * 2;
                    const r = 0.25 * (1 - Math.cos(angle));
                    return [-0.75 + r * Math.cos(angle), r * Math.sin(angle)];
                case 'figure8':
                    return [0.7 * Math.sin(t), 0.5 * Math.sin(2 * t)];
                case 'spiral':
                    const sr = 0.8 * Math.exp(-t * 0.1);
                    return [sr * Math.cos(t * 2), sr * Math.sin(t * 2)];
                case 'random':
                    state._randomTarget = state._randomTarget || [Math.random() * 1.5 - 0.75, Math.random() * 1.5 - 0.75];
                    state._randomCurrent = state._randomCurrent || [state.cReal, state.cImag];
                    const speed = 0.02;
                    state._randomCurrent[0] += (state._randomTarget[0] - state._randomCurrent[0]) * speed;
                    state._randomCurrent[1] += (state._randomTarget[1] - state._randomCurrent[1]) * speed;
                    if (Math.abs(state._randomTarget[0] - state._randomCurrent[0]) < 0.05) {
                        state._randomTarget = [Math.random() * 1.5 - 0.75, Math.random() * 1.5 - 0.75];
                    }
                    return state._randomCurrent;
                case 'presets':
                    const presetNames = Object.keys(juliaPresets);
                    const idx = Math.floor((t / (Math.PI * 2)) % 1 * presetNames.length);
                    const nextIdx = (idx + 1) % presetNames.length;
                    const localT = ((t / (Math.PI * 2)) % 1 * presetNames.length) % 1;
                    const smoothT = localT * localT * (3 - 2 * localT); // smoothstep
                    const p1 = juliaPresets[presetNames[idx]];
                    const p2 = juliaPresets[presetNames[nextIdx]];
                    return [
                        p1[0] + (p2[0] - p1[0]) * smoothT,
                        p1[1] + (p2[1] - p1[1]) * smoothT
                    ];
                default:
                    return [state.cReal, state.cImag];
            }
        }

        // High-res rendering
        async function renderHighRes(width, height, supersampling) {
            const modal = document.getElementById('hiResModal');
            const progressBar = document.getElementById('modalProgress');
            const progressText = document.getElementById('modalProgressText');
            modal.classList.add('visible');
            renderCancelled = false;

            const offscreen = document.createElement('canvas');
            offscreen.width = width;
            offscreen.height = height;
            const offCtx = offscreen.getContext('2d');
            const imgData = offCtx.createImageData(width, height);
            const data = imgData.data;

            const colorFn = colorSchemes[state.colorScheme];
            const maxIter = state.maxIter;
            const aspectRatio = width / height;
            const scale = 3 / state.zoom;
            const xMin = state.centerX - scale * aspectRatio / 2;
            const yMin = state.centerY - scale / 2;
            const xRange = scale * aspectRatio;
            const yRange = scale;

            const chunkSize = 50;

            for (let py = 0; py < height && !renderCancelled; py += chunkSize) {
                for (let chunkY = py; chunkY < Math.min(py + chunkSize, height) && !renderCancelled; chunkY++) {
                    for (let px = 0; px < width; px++) {
                        let totalR = 0, totalG = 0, totalB = 0;

                        for (let sy = 0; sy < supersampling; sy++) {
                            for (let sx = 0; sx < supersampling; sx++) {
                                const subX = px + sx / supersampling;
                                const subY = chunkY + sy / supersampling;

                                const x0 = xMin + (subX / width) * xRange;
                                const y0 = yMin + (subY / height) * yRange;

                                let zReal, zImag, cReal, cImag;
                                if (state.fractalType === 'julia' || state.fractalType === 'burningJulia') {
                                    zReal = x0; zImag = y0;
                                    cReal = state.cReal; cImag = state.cImag;
                                } else {
                                    zReal = 0; zImag = 0;
                                    cReal = x0; cImag = y0;
                                }

                                const burning = state.fractalType === 'burningShip' || state.fractalType === 'burningJulia';
                                let iter = 0;
                                let zReal2 = zReal * zReal;
                                let zImag2 = zImag * zImag;

                                while (zReal2 + zImag2 < state.escapeRadius * state.escapeRadius && iter < maxIter) {
                                    if (burning) {
                                        zImag = Math.abs(2 * zReal * zImag) + cImag;
                                    } else {
                                        zImag = 2 * zReal * zImag + cImag;
                                    }
                                    zReal = zReal2 - zImag2 + cReal;
                                    zReal2 = zReal * zReal;
                                    zImag2 = zImag * zImag;
                                    iter++;
                                }

                                let r, g, b;
                                if (iter === maxIter) {
                                    r = g = b = 0;
                                } else {
                                    const smooth = iter + 1 - Math.log2(Math.log(zReal2 + zImag2) / 2);
                                    const t = (smooth / maxIter) % 1;
                                    [r, g, b] = colorFn(t);
                                }
                                totalR += r;
                                totalG += g;
                                totalB += b;
                            }
                        }

                        const samples = supersampling * supersampling;
                        const idx = (chunkY * width + px) * 4;
                        data[idx] = totalR / samples;
                        data[idx + 1] = totalG / samples;
                        data[idx + 2] = totalB / samples;
                        data[idx + 3] = 255;
                    }
                }

                const progress = Math.floor((py / height) * 100);
                progressBar.style.width = progress + '%';
                progressText.textContent = `Rendering: ${progress}%`;

                // Allow UI to update
                await new Promise(r => setTimeout(r, 0));
            }

            if (!renderCancelled) {
                offCtx.putImageData(imgData, 0, 0);

                progressText.textContent = 'Saving...';

                const link = document.createElement('a');
                link.download = `fractal-${width}x${height}.png`;
                link.href = offscreen.toDataURL('image/png');
                link.click();
            }

            modal.classList.remove('visible');
        }

        // Event Listeners

        // Tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById('tab-' + tab.dataset.tab).classList.add('active');
            });
        });

        // Fractal type
        document.getElementById('fractalType').addEventListener('change', (e) => {
            state.fractalType = e.target.value;
            const juliaControls = document.getElementById('juliaControls');
            juliaControls.style.display = (state.fractalType === 'julia' || state.fractalType === 'burningJulia') ? 'block' : 'none';
            updateInfoPanel();
            needsRender = true;
        });

        // Mandelbrot preview click
        mandelbrotCanvas.addEventListener('click', (e) => {
            const rect = mandelbrotCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const xMin = -2.5, xMax = 1, yMin = -1.2, yMax = 1.2;
            state.cReal = xMin + (x / mandelbrotCanvas.width) * (xMax - xMin);
            state.cImag = yMin + (y / mandelbrotCanvas.height) * (yMax - yMin);
            updateCDisplay();
            renderMandelbrotPreview();
            updateInfoPanel();
            needsRender = true;
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        });

        // C sliders
        document.getElementById('cReal').addEventListener('input', (e) => {
            state.cReal = parseFloat(e.target.value);
            document.getElementById('cRealValue').textContent = state.cReal.toFixed(4);
            updateCDisplay();
            renderMandelbrotPreview();
            needsRender = true;
        });

        document.getElementById('cImag').addEventListener('input', (e) => {
            state.cImag = parseFloat(e.target.value);
            document.getElementById('cImagValue').textContent = state.cImag.toFixed(4);
            updateCDisplay();
            renderMandelbrotPreview();
            needsRender = true;
        });

        // Iteration and escape
        document.getElementById('maxIter').addEventListener('input', (e) => {
            state.maxIter = parseInt(e.target.value);
            document.getElementById('iterValue').textContent = state.maxIter;
            updateInfoPanel();
            needsRender = true;
        });

        document.getElementById('escapeRadius').addEventListener('input', (e) => {
            state.escapeRadius = parseInt(e.target.value);
            document.getElementById('escapeValue').textContent = state.escapeRadius;
            needsRender = true;
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const [cReal, cImag] = btn.dataset.c.split(',').map(Number);
                state.cReal = cReal;
                state.cImag = cImag;
                updateCDisplay();
                renderMandelbrotPreview();
                updateInfoPanel();
                needsRender = true;
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Color schemes
        document.querySelectorAll('.color-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                state.colorScheme = btn.dataset.scheme;
                needsRender = true;
                document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        // Color cycling
        document.getElementById('cycleSpeed').addEventListener('input', (e) => {
            state.cycleSpeed = parseFloat(e.target.value);
            document.getElementById('cycleSpeedValue').textContent = state.cycleSpeed.toFixed(1);
        });

        document.getElementById('interiorColor').addEventListener('change', (e) => {
            state.interiorColor = e.target.value;
            needsRender = true;
        });

        // Gradient editor
        document.getElementById('gradientBar').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            const color = document.getElementById('stopColor').value;
            state.customGradient.push({ pos, color });
            state.customGradient.sort((a, b) => a.pos - b.pos);
            state.selectedStop = state.customGradient.findIndex(s => s.pos === pos);
            updateGradientBar();
        });

        document.getElementById('stopColor').addEventListener('input', (e) => {
            if (state.selectedStop !== null && state.customGradient[state.selectedStop]) {
                state.customGradient[state.selectedStop].color = e.target.value;
                updateGradientBar();
            }
        });

        document.getElementById('removeStop').addEventListener('click', () => {
            if (state.selectedStop !== null && state.customGradient.length > 2) {
                state.customGradient.splice(state.selectedStop, 1);
                state.selectedStop = null;
                updateGradientBar();
            }
        });

        document.getElementById('applyGradient').addEventListener('click', () => {
            state.colorScheme = 'custom';
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            needsRender = true;
        });

        // Animation controls
        document.getElementById('animSpeed').addEventListener('input', (e) => {
            state.animSpeed = parseFloat(e.target.value);
            document.getElementById('animSpeedValue').textContent = state.animSpeed.toFixed(1);
        });

        document.getElementById('zoomSpeed').addEventListener('input', (e) => {
            state.zoomSpeed = parseFloat(e.target.value);
            document.getElementById('zoomSpeedValue').textContent = state.zoomSpeed.toFixed(1);
        });

        document.getElementById('animPath').addEventListener('change', (e) => {
            state.animPath = e.target.value;
        });

        document.getElementById('morphBtn').addEventListener('click', function() {
            state.morphing = !state.morphing;
            this.classList.toggle('active');
            this.textContent = state.morphing ? 'Stop Morphing' : 'Start Morphing';
        });

        document.getElementById('zoomAnimBtn').addEventListener('click', function() {
            state.zoomAnimating = !state.zoomAnimating;
            this.classList.toggle('active');
            this.textContent = state.zoomAnimating ? 'Stop Zoom' : 'Auto Zoom';
        });

        document.getElementById('zoomTarget').addEventListener('change', (e) => {
            const target = zoomTargets[e.target.value];
            if (target && state.fractalType === 'mandelbrot') {
                state.centerX = target.x;
                state.centerY = target.y;
                needsRender = true;
            }
        });

        // Action buttons
        document.getElementById('resetZoom').addEventListener('click', () => {
            state.centerX = 0;
            state.centerY = 0;
            state.zoom = 1;
            document.getElementById('zoomLevel').textContent = 'Zoom: 1x';
            updateInfoPanel();
            needsRender = true;
        });

        document.getElementById('splitViewBtn').addEventListener('click', function() {
            state.splitView = !state.splitView;
            this.classList.toggle('active');
            this.textContent = state.splitView ? 'Single View' : 'Split View';
            document.getElementById('splitDivider').classList.toggle('visible', state.splitView);
            needsRender = true;
        });

        document.getElementById('infoBtn').addEventListener('click', function() {
            state.showInfo = !state.showInfo;
            this.classList.toggle('active');
            document.getElementById('infoPanel').classList.toggle('visible', state.showInfo);
            updateInfoPanel();
        });

        document.getElementById('eduBtn').addEventListener('click', function() {
            state.showEducation = !state.showEducation;
            this.classList.toggle('active');
            document.getElementById('iterCanvas').classList.toggle('visible', state.showEducation);
            document.querySelector('.iter-label').classList.toggle('visible', state.showEducation);
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `fractal-${Date.now()}.png`;
            link.href = mainCanvas.toDataURL();
            link.click();
        });

        document.getElementById('hiResBtn').addEventListener('click', () => {
            const [width, height] = document.getElementById('exportRes').value.split(',').map(Number);
            const ss = parseInt(document.getElementById('exportSS').value);
            renderHighRes(width, height, ss);
        });

        document.getElementById('cancelRender').addEventListener('click', () => {
            renderCancelled = true;
        });

        // Canvas interaction
        let isDragging = false;
        let dragStartX, dragStartY, dragStartCenterX, dragStartCenterY;

        mainCanvas.addEventListener('mousedown', (e) => {
            if (e.button === 0) {
                isDragging = true;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                dragStartCenterX = state.centerX;
                dragStartCenterY = state.centerY;
                mainCanvas.style.cursor = 'grabbing';
            }
        });

        mainCanvas.addEventListener('mouseup', () => {
            isDragging = false;
            mainCanvas.style.cursor = 'crosshair';
        });

        mainCanvas.addEventListener('mouseleave', () => {
            isDragging = false;
            mainCanvas.style.cursor = 'crosshair';
        });

        mainCanvas.addEventListener('mousemove', (e) => {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const scale = 3 / state.zoom;
            const aspectRatio = width / height;

            const x = state.centerX + (e.clientX / width - 0.5) * scale * aspectRatio;
            const y = state.centerY + (e.clientY / height - 0.5) * scale;
            document.getElementById('coords').textContent = `${x.toFixed(6)}, ${y.toFixed(6)}`;

            if (isDragging) {
                const dx = (e.clientX - dragStartX) / width;
                const dy = (e.clientY - dragStartY) / height;
                state.centerX = dragStartCenterX - dx * scale * aspectRatio;
                state.centerY = dragStartCenterY - dy * scale;
                updateInfoPanel();
                needsRender = true;
            }
        });

        mainCanvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;

            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const scale = 3 / state.zoom;
            const aspectRatio = width / height;

            const mouseX = state.centerX + (e.clientX / width - 0.5) * scale * aspectRatio;
            const mouseY = state.centerY + (e.clientY / height - 0.5) * scale;

            state.zoom *= zoomFactor;

            const newScale = 3 / state.zoom;
            state.centerX = mouseX - (e.clientX / width - 0.5) * newScale * aspectRatio;
            state.centerY = mouseY - (e.clientY / height - 0.5) * newScale;

            document.getElementById('zoomLevel').textContent = `Zoom: ${state.zoom.toFixed(1)}x`;
            updateInfoPanel();
            needsRender = true;
        });

        mainCanvas.addEventListener('dblclick', (e) => {
            const width = mainCanvas.width;
            const height = mainCanvas.height;
            const scale = 3 / state.zoom;
            const aspectRatio = width / height;

            state.centerX += (e.clientX / width - 0.5) * scale * aspectRatio;
            state.centerY += (e.clientY / height - 0.5) * scale;
            state.zoom *= 2;

            document.getElementById('zoomLevel').textContent = `Zoom: ${state.zoom.toFixed(1)}x`;
            updateInfoPanel();
            needsRender = true;
        });

        mainCanvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            renderIterationPath(e.clientX, e.clientY);
        });

        // Split divider drag
        const divider = document.getElementById('splitDivider');
        divider.addEventListener('mousedown', (e) => {
            e.preventDefault();
            const onMove = (e) => {
                state.splitPos = Math.max(0.2, Math.min(0.8, e.clientX / window.innerWidth));
                divider.style.left = (state.splitPos * 100) + '%';
                needsRender = true;
            };
            const onUp = () => {
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onUp);
            };
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
        });

        // Animation loop
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;

        function animate() {
            requestAnimationFrame(animate);

            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = fps + ' FPS';
            }

            // Parameter morphing
            if (state.morphing && (state.fractalType === 'julia' || state.fractalType === 'burningJulia')) {
                state.animTime += 0.02 * state.animSpeed;
                const [cReal, cImag] = getAnimationC(state.animTime, state.animPath);
                state.cReal = cReal;
                state.cImag = cImag;
                updateCDisplay();
                renderMandelbrotPreview();
                updateInfoPanel();
                needsRender = true;
            }

            // Zoom animation
            if (state.zoomAnimating) {
                state.zoom *= 1 + 0.005 * state.zoomSpeed;
                document.getElementById('zoomLevel').textContent = `Zoom: ${state.zoom.toFixed(1)}x`;
                updateInfoPanel();
                needsRender = true;
            }

            // Color cycling
            if (state.cycleSpeed > 0) {
                state.cycleOffset += 0.001 * state.cycleSpeed;
                needsRender = true;
            }

            if (needsRender) {
                renderFractal();
                needsRender = false;
            }
        }

        // Init
        window.addEventListener('resize', init);
        init();
        updateCDisplay();
        updateInfoPanel();
        animate();

        console.log('Fractal Explorer running!');
    </script>
</body>
</html>
