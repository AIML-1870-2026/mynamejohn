<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pizza Decision Neuron üçï</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: linear-gradient(135deg, #1a0a0a 0%, #2d1810 50%, #1a0a0a 100%);
            color: #f0e6dc;
            font-family: 'Segoe UI', system-ui, sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr 300px;
            gap: 20px;
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
            min-height: 100vh;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(30, 15, 10, 0.95);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(255, 150, 50, 0.2);
            backdrop-filter: blur(10px);
        }

        h1 {
            font-size: 1.5em;
            color: #ff9933;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h2 {
            font-size: 1.1em;
            color: #ffaa44;
            margin-bottom: 12px;
            border-bottom: 1px solid rgba(255, 150, 50, 0.3);
            padding-bottom: 8px;
        }

        .subtitle {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 20px;
        }

        /* Neuron Visualization */
        .neuron-container {
            text-align: center;
            margin-bottom: 20px;
        }

        .neuron {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 0 auto 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 0 30px rgba(255, 150, 50, 0.3);
        }

        .neuron.thinking {
            background: radial-gradient(circle, #554433 0%, #332211 100%);
            border: 3px solid #666;
        }

        .neuron.yes {
            background: radial-gradient(circle, #44aa44 0%, #226622 100%);
            border: 3px solid #66dd66;
            animation: pulse-yes 0.5s ease;
        }

        .neuron.no {
            background: radial-gradient(circle, #aa4444 0%, #662222 100%);
            border: 3px solid #dd6666;
        }

        @keyframes pulse-yes {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .probability {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .decision-label {
            font-size: 1.2em;
            font-weight: 600;
        }

        /* Input Sliders */
        .input-group {
            margin-bottom: 16px;
        }

        .input-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .input-label {
            font-size: 0.85em;
            color: #ccc;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .input-value {
            font-size: 0.8em;
            color: #ff9933;
            font-weight: 600;
        }

        .weight-badge {
            font-size: 0.65em;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
        }

        .weight-positive { background: rgba(100, 200, 100, 0.3); color: #88dd88; }
        .weight-negative { background: rgba(200, 100, 100, 0.3); color: #dd8888; }

        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255, 150, 50, 0.2);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #ff9933, #ff6600);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255, 150, 50, 0.5);
        }

        /* Math Display */
        .math-display {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            margin-top: 15px;
            border: 1px solid rgba(255, 150, 50, 0.2);
            overflow-x: auto;
        }

        .math-line {
            margin: 4px 0;
            color: #aaa;
        }

        .math-line span {
            color: #ff9933;
        }

        /* Decision Boundary Canvas */
        .boundary-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #boundaryCanvas {
            width: 100%;
            flex: 1;
            min-height: 400px;
            border-radius: 12px;
            cursor: crosshair;
            background: #111;
        }

        .axis-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .axis-select {
            flex: 1;
            min-width: 120px;
        }

        .axis-select label {
            display: block;
            font-size: 0.75em;
            color: #888;
            margin-bottom: 4px;
        }

        .axis-select select {
            width: 100%;
            padding: 8px;
            background: rgba(30, 15, 10, 0.9);
            border: 1px solid rgba(255, 150, 50, 0.3);
            color: #f0e6dc;
            border-radius: 6px;
            font-size: 0.85em;
        }

        /* Training Panel */
        .training-controls {
            margin-bottom: 15px;
        }

        .mode-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .mode-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid rgba(255, 150, 50, 0.3);
            background: rgba(255, 150, 50, 0.1);
            color: #ccc;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.2s;
        }

        .mode-btn:hover {
            background: rgba(255, 150, 50, 0.2);
        }

        .mode-btn.active {
            background: rgba(255, 150, 50, 0.3);
            border-color: #ff9933;
            color: #fff;
        }

        .label-toggle {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .label-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s;
            text-align: center;
        }

        .label-btn.worth-it {
            border-color: rgba(100, 200, 100, 0.5);
            background: rgba(100, 200, 100, 0.1);
            color: #88dd88;
        }

        .label-btn.worth-it.active {
            background: rgba(100, 200, 100, 0.4);
            border-color: #66dd66;
        }

        .label-btn.skip-it {
            border-color: rgba(200, 100, 100, 0.5);
            background: rgba(200, 100, 100, 0.1);
            color: #dd8888;
        }

        .label-btn.skip-it.active {
            background: rgba(200, 100, 100, 0.4);
            border-color: #dd6666;
        }

        .action-btns {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .action-btn {
            padding: 10px 8px;
            background: rgba(255, 150, 50, 0.2);
            border: 1px solid rgba(255, 150, 50, 0.4);
            color: #f0e6dc;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8em;
            transition: all 0.2s;
        }

        .action-btn:hover {
            background: rgba(255, 150, 50, 0.35);
        }

        .action-btn.primary {
            background: rgba(255, 150, 50, 0.4);
            border-color: #ff9933;
        }

        /* Stats Display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #ff9933;
        }

        .stat-label {
            font-size: 0.7em;
            color: #888;
            margin-top: 2px;
        }

        /* Weights Display */
        .weights-display {
            margin-top: 15px;
        }

        .weight-bar-container {
            margin-bottom: 8px;
        }

        .weight-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.7em;
            margin-bottom: 3px;
        }

        .weight-bar-label span:first-child { color: #aaa; }
        .weight-bar-label span:last-child { color: #ff9933; font-family: monospace; }

        .weight-bar {
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .weight-bar-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease, background 0.3s ease;
            position: absolute;
        }

        .weight-bar-fill.positive {
            background: linear-gradient(90deg, #336633, #66aa66);
            left: 50%;
        }

        .weight-bar-fill.negative {
            background: linear-gradient(90deg, #aa6666, #663333);
            right: 50%;
        }

        .weight-bar-center {
            position: absolute;
            left: 50%;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
        }

        /* Presets */
        .presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 8px;
            background: rgba(255, 150, 50, 0.15);
            border: 1px solid rgba(255, 150, 50, 0.3);
            color: #ccc;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: rgba(255, 150, 50, 0.3);
            color: #fff;
        }

        /* Sensitivity Chart */
        #sensitivityCanvas {
            width: 100%;
            height: 150px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 10px;
        }

        /* Celebration */
        .celebration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .cheese-particle {
            position: absolute;
            font-size: 1.5em;
            animation: fall 2s ease-out forwards;
        }

        @keyframes fall {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* Learning Rate */
        .learning-rate {
            margin-bottom: 15px;
        }

        .learning-rate label {
            display: block;
            font-size: 0.8em;
            color: #aaa;
            margin-bottom: 6px;
        }

        .divider {
            height: 1px;
            background: rgba(255, 150, 50, 0.2);
            margin: 15px 0;
        }

        /* Activation comparison */
        .activation-selector {
            margin-bottom: 15px;
        }

        .activation-btns {
            display: flex;
            gap: 6px;
        }

        .activation-btn {
            flex: 1;
            padding: 6px;
            background: rgba(255, 150, 50, 0.1);
            border: 1px solid rgba(255, 150, 50, 0.3);
            color: #aaa;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.7em;
        }

        .activation-btn.active {
            background: rgba(255, 150, 50, 0.3);
            border-color: #ff9933;
            color: #fff;
        }

        #activationCanvas {
            width: 100%;
            height: 100px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            margin-top: 10px;
        }

        .help-text {
            font-size: 0.7em;
            color: #666;
            margin-top: 10px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="celebration" id="celebration"></div>

    <div class="container">
        <!-- Left Panel: Inputs -->
        <div class="panel">
            <h1>üçï Pizza Neuron</h1>
            <div class="subtitle">Should I order this pizza?</div>

            <div class="neuron-container">
                <div class="neuron thinking" id="neuron">üçï</div>
                <div class="probability" id="probability">50%</div>
                <div class="decision-label" id="decisionLabel">Thinking...</div>
            </div>

            <h2>Decision Factors</h2>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">
                        üßÄ Cheese Level
                        <span class="weight-badge weight-positive">+</span>
                    </span>
                    <span class="input-value" id="cheeseValue">0.50</span>
                </div>
                <input type="range" id="cheese" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">
                        üçÖ Sauce Quality
                        <span class="weight-badge weight-positive">+</span>
                    </span>
                    <span class="input-value" id="sauceValue">0.50</span>
                </div>
                <input type="range" id="sauce" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">
                        üçÑ Topping Variety
                        <span class="weight-badge weight-positive">+</span>
                    </span>
                    <span class="input-value" id="toppingsValue">0.50</span>
                </div>
                <input type="range" id="toppings" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">
                        üí∞ Price
                        <span class="weight-badge weight-negative">‚àí</span>
                    </span>
                    <span class="input-value" id="priceValue">0.50</span>
                </div>
                <input type="range" id="price" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">
                        üòã Hunger Level
                        <span class="weight-badge weight-positive">+</span>
                    </span>
                    <span class="input-value" id="hungerValue">0.50</span>
                </div>
                <input type="range" id="hunger" min="0" max="1" step="0.01" value="0.5">
            </div>

            <div class="divider"></div>

            <div class="input-group">
                <div class="input-header">
                    <span class="input-label">üçï Pizza Craving (Bias)</span>
                    <span class="input-value" id="biasValue">0.00</span>
                </div>
                <input type="range" id="bias" min="-3" max="3" step="0.1" value="0">
            </div>

            <div class="math-display" id="mathDisplay">
                <div class="math-line">z = Œ£(w·µ¢ √ó x·µ¢) + b</div>
                <div class="math-line">z = <span>0.00</span></div>
                <div class="math-line">œÉ(z) = 1 / (1 + e‚Åª·∂ª) = <span>0.50</span></div>
            </div>

            <div class="divider"></div>

            <h2>Activation Function</h2>
            <div class="activation-btns">
                <button class="activation-btn active" data-fn="sigmoid">Sigmoid</button>
                <button class="activation-btn" data-fn="step">Step</button>
                <button class="activation-btn" data-fn="relu">ReLU</button>
            </div>
            <canvas id="activationCanvas"></canvas>
        </div>

        <!-- Center Panel: Decision Boundary -->
        <div class="panel boundary-container">
            <h2>Decision Boundary</h2>

            <div class="axis-controls">
                <div class="axis-select">
                    <label>X-Axis</label>
                    <select id="xAxis">
                        <option value="cheese" selected>üßÄ Cheese Level</option>
                        <option value="sauce">üçÖ Sauce Quality</option>
                        <option value="toppings">üçÑ Toppings</option>
                        <option value="price">üí∞ Price</option>
                        <option value="hunger">üòã Hunger</option>
                    </select>
                </div>
                <div class="axis-select">
                    <label>Y-Axis</label>
                    <select id="yAxis">
                        <option value="cheese">üßÄ Cheese Level</option>
                        <option value="sauce">üçÖ Sauce Quality</option>
                        <option value="toppings">üçÑ Toppings</option>
                        <option value="price" selected>üí∞ Price</option>
                        <option value="hunger">üòã Hunger</option>
                    </select>
                </div>
            </div>

            <canvas id="boundaryCanvas"></canvas>

            <div class="help-text">
                <strong>Explore Mode:</strong> Move sliders to see the crosshair move on the boundary.<br>
                <strong>Training Mode:</strong> Click to add example points, then train the neuron!
            </div>
        </div>

        <!-- Right Panel: Training -->
        <div class="panel">
            <h2>Mode</h2>
            <div class="mode-toggle">
                <button class="mode-btn active" data-mode="explore">Explore</button>
                <button class="mode-btn" data-mode="train">Train</button>
            </div>

            <div id="trainControls" style="display: none;">
                <h2>Add Training Points</h2>
                <div class="label-toggle">
                    <button class="label-btn worth-it active" data-label="1">Worth It üçï</button>
                    <button class="label-btn skip-it" data-label="0">Skip It ‚ùå</button>
                </div>

                <div class="action-btns">
                    <button class="action-btn primary" id="stepBtn">Step</button>
                    <button class="action-btn" id="trainBtn">Train √ó10</button>
                    <button class="action-btn" id="resetBtn">Reset</button>
                </div>

                <div class="learning-rate">
                    <label>Learning Rate: <span id="lrValue">0.5</span></label>
                    <input type="range" id="learningRate" min="0.01" max="2" step="0.01" value="0.5">
                </div>

                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value" id="stepCount">0</div>
                        <div class="stat-label">Steps</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="accuracy">--</div>
                        <div class="stat-label">Accuracy</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="pointCount">0</div>
                        <div class="stat-label">Points</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value" id="lossValue">--</div>
                        <div class="stat-label">Loss</div>
                    </div>
                </div>

                <h2>Current Weights</h2>
                <div class="weights-display" id="weightsDisplay"></div>
            </div>

            <div id="exploreControls">
                <h2>Scenario Presets</h2>
                <div class="presets">
                    <button class="preset-btn" data-preset="lateNight">üåô Late Night</button>
                    <button class="preset-btn" data-preset="dietMode">ü•ó Diet Mode</button>
                    <button class="preset-btn" data-preset="treatYourself">üéâ Treat Yourself</button>
                    <button class="preset-btn" data-preset="budget">üí∏ On a Budget</button>
                </div>

                <div class="divider"></div>

                <h2>Sensitivity Analysis</h2>
                <canvas id="sensitivityCanvas"></canvas>
                <div class="help-text">
                    Shows how each input affects the probability when swept from 0 to 1 (other inputs held constant).
                </div>
            </div>
        </div>
    </div>

    <script>
        // Neuron weights and bias
        let weights = {
            cheese: 2.5,
            sauce: 1.8,
            toppings: 1.5,
            price: -3.0,
            hunger: 2.0
        };
        let bias = 0;

        // Current input values
        let inputs = {
            cheese: 0.5,
            sauce: 0.5,
            toppings: 0.5,
            price: 0.5,
            hunger: 0.5
        };

        // Training data
        let trainingPoints = [];
        let currentLabel = 1;
        let stepCount = 0;
        let learningRate = 0.5;
        let mode = 'explore';
        let activationFn = 'sigmoid';

        // Canvas contexts
        const boundaryCanvas = document.getElementById('boundaryCanvas');
        const boundaryCtx = boundaryCanvas.getContext('2d');
        const sensitivityCanvas = document.getElementById('sensitivityCanvas');
        const sensitivityCtx = sensitivityCanvas.getContext('2d');
        const activationCanvas = document.getElementById('activationCanvas');
        const activationCtx = activationCanvas.getContext('2d');

        // Axis selection
        let xAxisInput = 'cheese';
        let yAxisInput = 'price';

        // Activation functions
        function sigmoid(z) {
            return 1 / (1 + Math.exp(-z));
        }

        function step(z) {
            return z >= 0 ? 1 : 0;
        }

        function relu(z) {
            return Math.max(0, z);
        }

        function activate(z) {
            switch (activationFn) {
                case 'step': return step(z);
                case 'relu': return Math.min(1, relu(z) / 5); // Normalize for display
                default: return sigmoid(z);
            }
        }

        // Compute weighted sum
        function computeZ(inputValues) {
            let z = bias;
            for (const key in weights) {
                z += weights[key] * inputValues[key];
            }
            return z;
        }

        // Update neuron display
        function updateNeuron() {
            const z = computeZ(inputs);
            const prob = activate(z);
            const probPercent = Math.round(prob * 100);

            document.getElementById('probability').textContent = probPercent + '%';

            const neuron = document.getElementById('neuron');
            const label = document.getElementById('decisionLabel');

            neuron.classList.remove('thinking', 'yes', 'no');

            if (prob > 0.7) {
                neuron.classList.add('yes');
                label.textContent = 'Order it! üçï';
                label.style.color = '#66dd66';
                if (prob > 0.85 && Math.random() < 0.3) {
                    celebrate();
                }
            } else if (prob < 0.3) {
                neuron.classList.add('no');
                label.textContent = 'Skip it ‚ùå';
                label.style.color = '#dd6666';
            } else {
                neuron.classList.add('thinking');
                label.textContent = 'Hmm, maybe...';
                label.style.color = '#ccaa66';
            }

            // Update math display
            updateMathDisplay(z, prob);
        }

        function updateMathDisplay(z, prob) {
            const mathDiv = document.getElementById('mathDisplay');
            let terms = [];
            for (const key in weights) {
                const w = weights[key].toFixed(2);
                const x = inputs[key].toFixed(2);
                terms.push(`${w}√ó${x}`);
            }

            mathDiv.innerHTML = `
                <div class="math-line">z = ${terms.join(' + ')} + ${bias.toFixed(2)}</div>
                <div class="math-line">z = <span>${z.toFixed(3)}</span></div>
                <div class="math-line">${activationFn}(z) = <span>${prob.toFixed(4)}</span></div>
            `;
        }

        // Render decision boundary
        function renderBoundary() {
            const width = boundaryCanvas.width = boundaryCanvas.offsetWidth * 2;
            const height = boundaryCanvas.height = boundaryCanvas.offsetHeight * 2;
            const ctx = boundaryCtx;

            // Create heatmap
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    // Map pixel to input values
                    const xVal = px / width;
                    const yVal = 1 - py / height; // Flip Y

                    // Create input object with current values
                    const testInputs = { ...inputs };
                    testInputs[xAxisInput] = xVal;
                    testInputs[yAxisInput] = yVal;

                    const z = computeZ(testInputs);
                    const prob = sigmoid(z); // Always use sigmoid for visualization

                    // Color: red (no) -> white (uncertain) -> green (yes)
                    let r, g, b;
                    if (prob < 0.5) {
                        const t = prob * 2;
                        r = Math.floor(150 + (255 - 150) * t);
                        g = Math.floor(50 + (255 - 50) * t);
                        b = Math.floor(50 + (255 - 50) * t);
                    } else {
                        const t = (prob - 0.5) * 2;
                        r = Math.floor(255 - (255 - 50) * t);
                        g = Math.floor(255 - (255 - 180) * t);
                        b = Math.floor(255 - (255 - 50) * t);
                    }

                    const idx = (py * width + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Draw decision boundary line (where z = 0)
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 10;
            ctx.beginPath();

            let started = false;
            for (let px = 0; px < width; px++) {
                const xVal = px / width;

                // Find y where z = 0
                // z = w_x * xVal + w_y * yVal + (other terms) + bias = 0
                // yVal = -(w_x * xVal + other + bias) / w_y

                let otherTerms = bias;
                for (const key in weights) {
                    if (key !== xAxisInput && key !== yAxisInput) {
                        otherTerms += weights[key] * inputs[key];
                    }
                }
                otherTerms += weights[xAxisInput] * xVal;

                const yVal = -otherTerms / weights[yAxisInput];

                if (yVal >= 0 && yVal <= 1) {
                    const py = (1 - yVal) * height;
                    if (!started) {
                        ctx.moveTo(px, py);
                        started = true;
                    } else {
                        ctx.lineTo(px, py);
                    }
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Draw training points
            trainingPoints.forEach(point => {
                const px = point[xAxisInput] * width;
                const py = (1 - point[yAxisInput]) * height;

                ctx.beginPath();
                ctx.arc(px, py, 12, 0, Math.PI * 2);

                if (point.label === 1) {
                    ctx.fillStyle = 'rgba(100, 200, 100, 0.9)';
                    ctx.strokeStyle = '#66dd66';
                } else {
                    ctx.fillStyle = 'rgba(200, 100, 100, 0.9)';
                    ctx.strokeStyle = '#dd6666';
                }
                ctx.lineWidth = 3;
                ctx.fill();
                ctx.stroke();

                // Draw emoji
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(point.label === 1 ? 'üçï' : '‚ùå', px, py);
            });

            // Draw current position crosshair
            const currentX = inputs[xAxisInput] * width;
            const currentY = (1 - inputs[yAxisInput]) * height;

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);

            // Vertical line
            ctx.beginPath();
            ctx.moveTo(currentX, 0);
            ctx.lineTo(currentX, height);
            ctx.stroke();

            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(0, currentY);
            ctx.lineTo(width, currentY);
            ctx.stroke();

            ctx.setLineDash([]);

            // Draw crosshair dot
            ctx.beginPath();
            ctx.arc(currentX, currentY, 10, 0, Math.PI * 2);
            ctx.fillStyle = '#ff9933';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Axis labels
            ctx.font = '24px Arial';
            ctx.fillStyle = '#888';
            ctx.textAlign = 'center';

            const xLabel = document.querySelector(`#xAxis option[value="${xAxisInput}"]`).textContent;
            const yLabel = document.querySelector(`#yAxis option[value="${yAxisInput}"]`).textContent;

            ctx.fillText(xLabel + ' ‚Üí', width / 2, height - 15);

            ctx.save();
            ctx.translate(25, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel + ' ‚Üí', 0, 0);
            ctx.restore();
        }

        // Render sensitivity analysis
        function renderSensitivity() {
            const width = sensitivityCanvas.width = sensitivityCanvas.offsetWidth * 2;
            const height = sensitivityCanvas.height = sensitivityCanvas.offsetHeight * 2;
            const ctx = sensitivityCtx;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            const colors = {
                cheese: '#ffcc00',
                sauce: '#ff4444',
                toppings: '#88cc44',
                price: '#4488ff',
                hunger: '#ff88cc'
            };

            const padding = 40;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;

            // Draw axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();

            // Draw each input's sensitivity curve
            for (const key in weights) {
                ctx.strokeStyle = colors[key];
                ctx.lineWidth = 3;
                ctx.beginPath();

                for (let i = 0; i <= 100; i++) {
                    const xVal = i / 100;
                    const testInputs = { ...inputs };
                    testInputs[key] = xVal;
                    const prob = sigmoid(computeZ(testInputs));

                    const px = padding + xVal * graphWidth;
                    const py = height - padding - prob * graphHeight;

                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Draw current value marker
                const currentX = padding + inputs[key] * graphWidth;
                const currentProb = sigmoid(computeZ(inputs));
                const currentY = height - padding - currentProb * graphHeight;

                ctx.beginPath();
                ctx.arc(currentX, currentY, 6, 0, Math.PI * 2);
                ctx.fillStyle = colors[key];
                ctx.fill();
            }

            // Legend
            ctx.font = '18px sans-serif';
            let legendX = padding;
            for (const key in weights) {
                ctx.fillStyle = colors[key];
                ctx.fillText(key.charAt(0).toUpperCase() + key.slice(1), legendX, 25);
                legendX += 70;
            }
        }

        // Render activation function comparison
        function renderActivation() {
            const width = activationCanvas.width = activationCanvas.offsetWidth * 2;
            const height = activationCanvas.height = activationCanvas.offsetHeight * 2;
            const ctx = activationCtx;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(0, 0, width, height);

            const padding = 20;
            const graphWidth = width - padding * 2;
            const graphHeight = height - padding * 2;

            // Draw sigmoid
            ctx.strokeStyle = activationFn === 'sigmoid' ? '#ff9933' : '#555';
            ctx.lineWidth = activationFn === 'sigmoid' ? 3 : 1;
            ctx.beginPath();
            for (let i = 0; i <= 100; i++) {
                const z = (i / 100) * 10 - 5;
                const y = sigmoid(z);
                const px = padding + (i / 100) * graphWidth;
                const py = height - padding - y * graphHeight;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();

            // Draw step
            ctx.strokeStyle = activationFn === 'step' ? '#ff9933' : '#555';
            ctx.lineWidth = activationFn === 'step' ? 3 : 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width / 2, height - padding);
            ctx.lineTo(width / 2, padding);
            ctx.lineTo(width - padding, padding);
            ctx.stroke();

            // Draw ReLU
            ctx.strokeStyle = activationFn === 'relu' ? '#ff9933' : '#555';
            ctx.lineWidth = activationFn === 'relu' ? 3 : 1;
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width / 2, height - padding);
            ctx.lineTo(width - padding, padding);
            ctx.stroke();

            // Draw current z marker
            const currentZ = computeZ(inputs);
            const normalizedZ = (currentZ + 5) / 10; // Map to 0-1
            if (normalizedZ >= 0 && normalizedZ <= 1) {
                const markerX = padding + normalizedZ * graphWidth;
                const markerY = height - padding - activate(currentZ) * graphHeight;

                ctx.beginPath();
                ctx.arc(markerX, markerY, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#ff9933';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // Training step
        function trainStep() {
            if (trainingPoints.length === 0) return;

            // Pick a random point
            const point = trainingPoints[Math.floor(Math.random() * trainingPoints.length)];

            // Compute prediction
            const z = computeZ(point);
            const prediction = sigmoid(z);
            const error = point.label - prediction;

            // Update weights using gradient descent
            for (const key in weights) {
                weights[key] += learningRate * error * prediction * (1 - prediction) * point[key];
            }
            bias += learningRate * error * prediction * (1 - prediction);

            stepCount++;
            updateStats();
            renderBoundary();
            updateWeightsDisplay();
        }

        function updateStats() {
            document.getElementById('stepCount').textContent = stepCount;
            document.getElementById('pointCount').textContent = trainingPoints.length;

            if (trainingPoints.length > 0) {
                // Calculate accuracy
                let correct = 0;
                let totalLoss = 0;
                trainingPoints.forEach(point => {
                    const prob = sigmoid(computeZ(point));
                    const predicted = prob >= 0.5 ? 1 : 0;
                    if (predicted === point.label) correct++;

                    // Binary cross-entropy loss
                    const loss = -point.label * Math.log(prob + 0.0001) - (1 - point.label) * Math.log(1 - prob + 0.0001);
                    totalLoss += loss;
                });

                const accuracy = Math.round((correct / trainingPoints.length) * 100);
                document.getElementById('accuracy').textContent = accuracy + '%';
                document.getElementById('lossValue').textContent = (totalLoss / trainingPoints.length).toFixed(3);
            }
        }

        function updateWeightsDisplay() {
            const container = document.getElementById('weightsDisplay');
            container.innerHTML = '';

            const maxWeight = 5;

            for (const key in weights) {
                const w = weights[key];
                const absW = Math.abs(w);
                const percentage = Math.min(absW / maxWeight, 1) * 50;

                const div = document.createElement('div');
                div.className = 'weight-bar-container';
                div.innerHTML = `
                    <div class="weight-bar-label">
                        <span>${key}</span>
                        <span>${w.toFixed(3)}</span>
                    </div>
                    <div class="weight-bar">
                        <div class="weight-bar-center"></div>
                        <div class="weight-bar-fill ${w >= 0 ? 'positive' : 'negative'}"
                             style="width: ${percentage}%"></div>
                    </div>
                `;
                container.appendChild(div);
            }

            // Add bias
            const biasDiv = document.createElement('div');
            biasDiv.className = 'weight-bar-container';
            const biasPercentage = Math.min(Math.abs(bias) / maxWeight, 1) * 50;
            biasDiv.innerHTML = `
                <div class="weight-bar-label">
                    <span>bias</span>
                    <span>${bias.toFixed(3)}</span>
                </div>
                <div class="weight-bar">
                    <div class="weight-bar-center"></div>
                    <div class="weight-bar-fill ${bias >= 0 ? 'positive' : 'negative'}"
                         style="width: ${biasPercentage}%"></div>
                </div>
            `;
            container.appendChild(biasDiv);
        }

        // Celebration effect
        function celebrate() {
            const container = document.getElementById('celebration');
            const emojis = ['üçï', 'üßÄ', 'üçÖ', 'üéâ', '‚ú®'];

            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const particle = document.createElement('div');
                    particle.className = 'cheese-particle';
                    particle.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    particle.style.left = Math.random() * 100 + 'vw';
                    particle.style.animationDuration = (1.5 + Math.random()) + 's';
                    container.appendChild(particle);

                    setTimeout(() => particle.remove(), 2000);
                }, i * 100);
            }
        }

        // Presets
        const presets = {
            lateNight: {
                cheese: 0.7, sauce: 0.5, toppings: 0.4, price: 0.6, hunger: 0.9, bias: 1.5
            },
            dietMode: {
                cheese: 0.3, sauce: 0.4, toppings: 0.6, price: 0.4, hunger: 0.3, bias: -2
            },
            treatYourself: {
                cheese: 0.9, sauce: 0.8, toppings: 0.9, price: 0.3, hunger: 0.7, bias: 2
            },
            budget: {
                cheese: 0.5, sauce: 0.5, toppings: 0.3, price: 0.8, hunger: 0.5, bias: -1
            }
        };

        function applyPreset(presetName) {
            const preset = presets[presetName];
            for (const key in preset) {
                if (key === 'bias') {
                    bias = preset[key];
                    document.getElementById('bias').value = bias;
                    document.getElementById('biasValue').textContent = bias.toFixed(2);
                } else {
                    inputs[key] = preset[key];
                    document.getElementById(key).value = preset[key];
                    document.getElementById(key + 'Value').textContent = preset[key].toFixed(2);
                }
            }
            updateAll();
        }

        function updateAll() {
            updateNeuron();
            renderBoundary();
            renderSensitivity();
            renderActivation();
        }

        // Event Listeners

        // Input sliders
        ['cheese', 'sauce', 'toppings', 'price', 'hunger'].forEach(id => {
            document.getElementById(id).addEventListener('input', (e) => {
                inputs[id] = parseFloat(e.target.value);
                document.getElementById(id + 'Value').textContent = inputs[id].toFixed(2);
                updateAll();
            });
        });

        document.getElementById('bias').addEventListener('input', (e) => {
            bias = parseFloat(e.target.value);
            document.getElementById('biasValue').textContent = bias.toFixed(2);
            updateAll();
        });

        // Axis selection
        document.getElementById('xAxis').addEventListener('change', (e) => {
            xAxisInput = e.target.value;
            renderBoundary();
        });

        document.getElementById('yAxis').addEventListener('change', (e) => {
            yAxisInput = e.target.value;
            renderBoundary();
        });

        // Mode toggle
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                mode = btn.dataset.mode;

                document.getElementById('trainControls').style.display = mode === 'train' ? 'block' : 'none';
                document.getElementById('exploreControls').style.display = mode === 'explore' ? 'block' : 'none';

                if (mode === 'train') {
                    updateWeightsDisplay();
                }
            });
        });

        // Label toggle
        document.querySelectorAll('.label-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.label-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentLabel = parseInt(btn.dataset.label);
            });
        });

        // Training controls
        document.getElementById('stepBtn').addEventListener('click', trainStep);

        document.getElementById('trainBtn').addEventListener('click', () => {
            for (let i = 0; i < 10; i++) {
                setTimeout(trainStep, i * 100);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            trainingPoints = [];
            stepCount = 0;
            weights = { cheese: 2.5, sauce: 1.8, toppings: 1.5, price: -3.0, hunger: 2.0 };
            bias = 0;
            document.getElementById('bias').value = 0;
            document.getElementById('biasValue').textContent = '0.00';
            updateStats();
            updateWeightsDisplay();
            renderBoundary();
        });

        document.getElementById('learningRate').addEventListener('input', (e) => {
            learningRate = parseFloat(e.target.value);
            document.getElementById('lrValue').textContent = learningRate.toFixed(2);
        });

        // Canvas click for adding points
        boundaryCanvas.addEventListener('click', (e) => {
            if (mode !== 'train') return;

            const rect = boundaryCanvas.getBoundingClientRect();
            const scaleX = boundaryCanvas.width / rect.width;
            const scaleY = boundaryCanvas.height / rect.height;

            const x = (e.clientX - rect.left) * scaleX / boundaryCanvas.width;
            const y = 1 - (e.clientY - rect.top) * scaleY / boundaryCanvas.height;

            const point = { ...inputs };
            point[xAxisInput] = Math.max(0, Math.min(1, x));
            point[yAxisInput] = Math.max(0, Math.min(1, y));
            point.label = currentLabel;

            trainingPoints.push(point);
            updateStats();
            renderBoundary();
        });

        // Presets
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                applyPreset(btn.dataset.preset);
            });
        });

        // Activation function
        document.querySelectorAll('.activation-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.activation-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                activationFn = btn.dataset.fn;
                updateAll();
            });
        });

        // Initialize
        window.addEventListener('resize', () => {
            renderBoundary();
            renderSensitivity();
            renderActivation();
        });

        updateAll();
        updateWeightsDisplay();

        console.log('üçï Pizza Decision Neuron ready!');
    </script>
</body>
</html>
