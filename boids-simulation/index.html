<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids Flocking Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a0a0a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        canvas {
            display: block;
        }

        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(100, 100, 150, 0.3);
            border-radius: 12px;
            padding: 20px;
            color: #e0e0e0;
            width: 280px;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
            z-index: 100;
        }

        #controls.collapsed {
            transform: translateX(calc(100% + 10px));
        }

        #toggle-btn {
            position: fixed;
            top: 20px;
            right: 310px;
            background: rgba(20, 20, 30, 0.9);
            border: 1px solid rgba(100, 100, 150, 0.3);
            border-radius: 8px;
            color: #e0e0e0;
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            z-index: 101;
        }

        #toggle-btn:hover {
            background: rgba(40, 40, 60, 0.9);
        }

        #toggle-btn.collapsed {
            right: 20px;
        }

        h2 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 13px;
            color: #a0a0a0;
        }

        .control-value {
            color: #70b0ff;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(100, 100, 150, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #70b0ff;
            cursor: pointer;
            transition: transform 0.1s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .mouse-modes {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .mouse-mode-btn {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(100, 100, 150, 0.3);
            background: rgba(40, 40, 60, 0.5);
            color: #a0a0a0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .mouse-mode-btn:hover {
            background: rgba(60, 60, 90, 0.5);
        }

        .mouse-mode-btn.active {
            background: rgba(70, 130, 220, 0.4);
            border-color: #70b0ff;
            color: #fff;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .action-btn {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .reset-btn {
            background: rgba(100, 100, 150, 0.3);
            color: #e0e0e0;
        }

        .reset-btn:hover {
            background: rgba(100, 100, 150, 0.5);
        }

        .randomize-btn {
            background: rgba(70, 130, 220, 0.4);
            color: #fff;
        }

        .randomize-btn:hover {
            background: rgba(70, 130, 220, 0.6);
        }

        #fps {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(150, 150, 150, 0.6);
            font-size: 12px;
            font-family: monospace;
        }

        #info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(150, 150, 150, 0.6);
            font-size: 12px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <button id="toggle-btn">Hide</button>

    <div id="controls">
        <h2>Boids Simulation</h2>

        <div class="control-group">
            <div class="control-label">
                <span>Separation</span>
                <span class="control-value" id="separation-value">1.5</span>
            </div>
            <input type="range" id="separation" min="0" max="5" step="0.1" value="1.5">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Alignment</span>
                <span class="control-value" id="alignment-value">1.0</span>
            </div>
            <input type="range" id="alignment" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Cohesion</span>
                <span class="control-value" id="cohesion-value">1.0</span>
            </div>
            <input type="range" id="cohesion" min="0" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Neighbor Radius</span>
                <span class="control-value" id="radius-value">50</span>
            </div>
            <input type="range" id="radius" min="10" max="200" step="5" value="50">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Max Speed</span>
                <span class="control-value" id="speed-value">4</span>
            </div>
            <input type="range" id="speed" min="1" max="15" step="0.5" value="4">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Tail Length</span>
                <span class="control-value" id="tail-value">10</span>
            </div>
            <input type="range" id="tail" min="0" max="50" step="1" value="10">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Bird Count</span>
                <span class="control-value" id="count-value">100</span>
            </div>
            <input type="range" id="count" min="10" max="500" step="10" value="100">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Mouse Mode</span>
            </div>
            <div class="mouse-modes">
                <button class="mouse-mode-btn" data-mode="leader">Leader</button>
                <button class="mouse-mode-btn" data-mode="predator">Predator</button>
                <button class="mouse-mode-btn active" data-mode="off">Off</button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Hawk Predator</span>
            </div>
            <div class="mouse-modes">
                <button class="mouse-mode-btn" id="hawk-on">Enable Hawk</button>
                <button class="mouse-mode-btn active" id="hawk-off">No Hawk</button>
            </div>
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Evasion Intensity</span>
                <span class="control-value" id="evasion-value">2.0</span>
            </div>
            <input type="range" id="evasion" min="0" max="5" step="0.1" value="2.0">
        </div>

        <div class="control-group">
            <div class="control-label">
                <span>Panic Flock Multiplier</span>
                <span class="control-value" id="panic-value">3.0</span>
            </div>
            <input type="range" id="panic" min="1" max="10" step="0.5" value="3.0">
        </div>

        <div class="button-group">
            <button class="action-btn reset-btn" id="reset">Reset</button>
            <button class="action-btn randomize-btn" id="randomize">Randomize</button>
        </div>
    </div>

    <div id="fps">FPS: 60</div>
    <div id="info">Click and drag to interact</div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Configuration
        const config = {
            separationWeight: 1.5,
            alignmentWeight: 1.0,
            cohesionWeight: 1.0,
            neighborRadius: 50,
            maxSpeed: 4,
            tailLength: 10,
            birdCount: 100,
            mouseMode: 'off',
            hawkEnabled: false,
            evasionIntensity: 2.0,
            panicFlockMultiplier: 3.0
        };

        let boids = [];
        let hawk = null;
        let mousePos = { x: 0, y: 0 };
        let mouseActive = false;

        // Hawk Predator class
        class Hawk {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.targetBoid = null;
                this.huntCooldown = 0;
                this.history = [];
            }

            update(boids) {
                // Store history for trail
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > 20) this.history.shift();

                // Find closest boid to hunt
                if (!this.targetBoid || this.huntCooldown <= 0 || Math.random() < 0.01) {
                    let closestDist = Infinity;
                    for (const boid of boids) {
                        const dx = boid.x - this.x;
                        const dy = boid.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < closestDist) {
                            closestDist = dist;
                            this.targetBoid = boid;
                        }
                    }
                    this.huntCooldown = 120; // Re-evaluate target every 2 seconds
                }
                this.huntCooldown--;

                // Chase target with some prediction
                if (this.targetBoid) {
                    const predictX = this.targetBoid.x + this.targetBoid.vx * 10;
                    const predictY = this.targetBoid.y + this.targetBoid.vy * 10;
                    const dx = predictX - this.x;
                    const dy = predictY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist > 0) {
                        this.vx += (dx / dist) * 0.3;
                        this.vy += (dy / dist) * 0.3;
                    }
                }

                // Add some wandering behavior
                this.vx += (Math.random() - 0.5) * 0.2;
                this.vy += (Math.random() - 0.5) * 0.2;

                // Limit speed (hawk is faster than boids)
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                const maxHawkSpeed = config.maxSpeed * 1.5;
                if (speed > maxHawkSpeed) {
                    this.vx = (this.vx / speed) * maxHawkSpeed;
                    this.vy = (this.vy / speed) * maxHawkSpeed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges
                if (this.x < 0) this.x += canvas.width;
                if (this.x > canvas.width) this.x -= canvas.width;
                if (this.y < 0) this.y += canvas.height;
                if (this.y > canvas.height) this.y -= canvas.height;
            }

            draw() {
                // Draw trail
                if (this.history.length > 1) {
                    for (let i = 0; i < this.history.length - 1; i++) {
                        const alpha = (i / this.history.length) * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(this.history[i].x, this.history[i].y);
                        ctx.lineTo(this.history[i + 1].x, this.history[i + 1].y);
                        ctx.strokeStyle = `rgba(255, 50, 50, ${alpha})`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // Draw hawk as larger triangle
                const angle = Math.atan2(this.vy, this.vx);
                const size = 16;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);

                // Hawk body
                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size * 0.7, size * 0.6);
                ctx.lineTo(-size * 0.3, 0);
                ctx.lineTo(-size * 0.7, -size * 0.6);
                ctx.closePath();

                ctx.fillStyle = '#ff3333';
                ctx.fill();
                ctx.strokeStyle = '#ff6666';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Glow effect
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 15;
                ctx.fill();
                ctx.shadowBlur = 0;

                ctx.restore();
            }
        }

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener('resize', resize);

        // Mouse tracking
        canvas.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX;
            mousePos.y = e.clientY;
        });

        canvas.addEventListener('mouseenter', () => mouseActive = true);
        canvas.addEventListener('mouseleave', () => mouseActive = false);

        // Boid class
        class Boid {
            constructor(x, y) {
                this.x = x || Math.random() * canvas.width;
                this.y = y || Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.history = [];
                this.baseHue = Math.random() * 60 + 180; // Blue-cyan range
                this.hue = this.baseHue;
                this.threatLevel = 0; // 0 = calm, 1 = maximum panic
                this.evasionCooldown = 0;
                this.lastEvasionAngle = 0;
            }

            detectThreat() {
                let maxThreat = 0;
                const threatRadius = 150;

                // Check hawk threat
                if (config.hawkEnabled && hawk) {
                    const dx = hawk.x - this.x;
                    const dy = hawk.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < threatRadius) {
                        maxThreat = Math.max(maxThreat, 1 - (dist / threatRadius));
                    }
                }

                // Check mouse predator threat
                if (mouseActive && config.mouseMode === 'predator') {
                    const dx = mousePos.x - this.x;
                    const dy = mousePos.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < threatRadius) {
                        maxThreat = Math.max(maxThreat, 1 - (dist / threatRadius));
                    }
                }

                // Smooth threat level transition
                this.threatLevel += (maxThreat - this.threatLevel) * 0.1;
                return this.threatLevel;
            }

            evade() {
                let evadeX = 0, evadeY = 0;
                const evasionRadius = 120;

                // Evade hawk
                if (config.hawkEnabled && hawk) {
                    const dx = hawk.x - this.x;
                    const dy = hawk.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < evasionRadius) {
                        const urgency = (1 - dist / evasionRadius) * config.evasionIntensity;

                        // Direct flee
                        evadeX -= (dx / dist) * urgency * 0.5;
                        evadeY -= (dy / dist) * urgency * 0.5;

                        // Evasive maneuver - sharp random turn when very close
                        if (dist < 60 && this.evasionCooldown <= 0) {
                            // Pick a perpendicular direction with some randomness
                            const perpAngle = Math.atan2(-dx, dy) + (Math.random() - 0.5) * Math.PI * 0.5;
                            this.lastEvasionAngle = perpAngle;
                            this.evasionCooldown = 15; // Frames before next evasion

                            evadeX += Math.cos(perpAngle) * urgency * 2;
                            evadeY += Math.sin(perpAngle) * urgency * 2;
                        } else if (this.evasionCooldown > 0) {
                            // Continue evasion direction briefly
                            evadeX += Math.cos(this.lastEvasionAngle) * urgency * 0.5;
                            evadeY += Math.sin(this.lastEvasionAngle) * urgency * 0.5;
                        }
                    }
                }

                // Evade mouse predator
                if (mouseActive && config.mouseMode === 'predator') {
                    const dx = mousePos.x - this.x;
                    const dy = mousePos.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < evasionRadius) {
                        const urgency = (1 - dist / evasionRadius) * config.evasionIntensity;
                        evadeX -= (dx / dist) * urgency * 0.5;
                        evadeY -= (dy / dist) * urgency * 0.5;

                        // Sharp evasive turn
                        if (dist < 60 && this.evasionCooldown <= 0) {
                            const perpAngle = Math.atan2(-dx, dy) + (Math.random() - 0.5) * Math.PI * 0.5;
                            this.lastEvasionAngle = perpAngle;
                            this.evasionCooldown = 15;

                            evadeX += Math.cos(perpAngle) * urgency * 2;
                            evadeY += Math.sin(perpAngle) * urgency * 2;
                        } else if (this.evasionCooldown > 0) {
                            evadeX += Math.cos(this.lastEvasionAngle) * urgency * 0.5;
                            evadeY += Math.sin(this.lastEvasionAngle) * urgency * 0.5;
                        }
                    }
                }

                this.evasionCooldown = Math.max(0, this.evasionCooldown - 1);
                return { x: evadeX, y: evadeY };
            }

            update(boids) {
                // Store position history for tail
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > config.tailLength) {
                    this.history.shift();
                }

                // Detect threats and update threat level
                this.detectThreat();

                // Update color based on threat (blue -> red)
                this.hue = this.baseHue - (this.threatLevel * 180); // Shifts toward red when threatened

                // Get neighbors
                const neighbors = this.getNeighbors(boids);

                // Apply flocking rules with panic modifiers
                const separation = this.separate(neighbors);
                const alignment = this.align(neighbors);
                const cohesion = this.cohere(neighbors);

                // Panic flocking: when threatened, massively increase cohesion and alignment
                const panicMultiplier = 1 + (this.threatLevel * (config.panicFlockMultiplier - 1));

                // Apply weights (separation stays same, cohesion/alignment increase under threat)
                this.vx += separation.x * config.separationWeight;
                this.vy += separation.y * config.separationWeight;
                this.vx += alignment.x * config.alignmentWeight * panicMultiplier;
                this.vy += alignment.y * config.alignmentWeight * panicMultiplier;
                this.vx += cohesion.x * config.cohesionWeight * panicMultiplier;
                this.vy += cohesion.y * config.cohesionWeight * panicMultiplier;

                // Apply evasive maneuvers
                const evasion = this.evade();
                this.vx += evasion.x;
                this.vy += evasion.y;

                // Mouse interaction (leader mode only when not panicking)
                if (mouseActive && config.mouseMode === 'leader' && this.threatLevel < 0.3) {
                    const mouse = this.mouseInfluence();
                    this.vx += mouse.x;
                    this.vy += mouse.y;
                }

                // Limit speed (allow faster when panicking)
                const panicSpeedBoost = 1 + (this.threatLevel * 0.5);
                const currentMaxSpeed = config.maxSpeed * panicSpeedBoost;
                const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                if (speed > currentMaxSpeed) {
                    this.vx = (this.vx / speed) * currentMaxSpeed;
                    this.vy = (this.vy / speed) * currentMaxSpeed;
                }

                // Update position
                this.x += this.vx;
                this.y += this.vy;

                // Wrap around edges
                if (this.x < 0) this.x += canvas.width;
                if (this.x > canvas.width) this.x -= canvas.width;
                if (this.y < 0) this.y += canvas.height;
                if (this.y > canvas.height) this.y -= canvas.height;
            }

            getNeighbors(boids) {
                const neighbors = [];
                for (const other of boids) {
                    if (other === this) continue;
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < config.neighborRadius) {
                        neighbors.push({ boid: other, dist });
                    }
                }
                return neighbors;
            }

            separate(neighbors) {
                let steerX = 0, steerY = 0;
                for (const { boid, dist } of neighbors) {
                    if (dist < config.neighborRadius * 0.5) {
                        const factor = 1 - (dist / (config.neighborRadius * 0.5));
                        steerX -= (boid.x - this.x) * factor * 0.05;
                        steerY -= (boid.y - this.y) * factor * 0.05;
                    }
                }
                return { x: steerX, y: steerY };
            }

            align(neighbors) {
                if (neighbors.length === 0) return { x: 0, y: 0 };
                let avgVx = 0, avgVy = 0;
                for (const { boid } of neighbors) {
                    avgVx += boid.vx;
                    avgVy += boid.vy;
                }
                avgVx /= neighbors.length;
                avgVy /= neighbors.length;
                return {
                    x: (avgVx - this.vx) * 0.05,
                    y: (avgVy - this.vy) * 0.05
                };
            }

            cohere(neighbors) {
                if (neighbors.length === 0) return { x: 0, y: 0 };
                let centerX = 0, centerY = 0;
                for (const { boid } of neighbors) {
                    centerX += boid.x;
                    centerY += boid.y;
                }
                centerX /= neighbors.length;
                centerY /= neighbors.length;
                return {
                    x: (centerX - this.x) * 0.005,
                    y: (centerY - this.y) * 0.005
                };
            }

            mouseInfluence() {
                const dx = mousePos.x - this.x;
                const dy = mousePos.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > 200) return { x: 0, y: 0 };

                const factor = (1 - dist / 200) * 0.5;

                if (config.mouseMode === 'leader') {
                    return { x: dx * factor * 0.02, y: dy * factor * 0.02 };
                }
                // Predator mode now handled by evade() method
                return { x: 0, y: 0 };
            }

            draw() {
                // Draw tail
                if (this.history.length > 1) {
                    for (let i = 0; i < this.history.length - 1; i++) {
                        const alpha = (i / this.history.length) * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.history[i].x, this.history[i].y);
                        ctx.lineTo(this.history[i + 1].x, this.history[i + 1].y);
                        ctx.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

                // Draw boid as triangle
                const angle = Math.atan2(this.vy, this.vx);
                const size = 8;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(angle);

                ctx.beginPath();
                ctx.moveTo(size, 0);
                ctx.lineTo(-size * 0.6, size * 0.4);
                ctx.lineTo(-size * 0.6, -size * 0.4);
                ctx.closePath();

                ctx.fillStyle = `hsl(${this.hue}, 70%, 60%)`;
                ctx.fill();

                ctx.restore();
            }
        }

        // Initialize boids
        function initBoids() {
            boids = [];
            for (let i = 0; i < config.birdCount; i++) {
                boids.push(new Boid());
            }
        }
        initBoids();

        // FPS tracking
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;

        // Animation loop
        function animate() {
            // Calculate FPS
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastTime = now;
                document.getElementById('fps').textContent = `FPS: ${fps}`;
            }

            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 15, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Update and draw hawk
            if (config.hawkEnabled && hawk) {
                hawk.update(boids);
                hawk.draw();
            }

            // Update and draw boids
            for (const boid of boids) {
                boid.update(boids);
                boid.draw();
            }

            requestAnimationFrame(animate);
        }
        animate();

        // Control panel bindings
        const controls = {
            separation: { key: 'separationWeight', decimals: 1 },
            alignment: { key: 'alignmentWeight', decimals: 1 },
            cohesion: { key: 'cohesionWeight', decimals: 1 },
            radius: { key: 'neighborRadius', decimals: 0 },
            speed: { key: 'maxSpeed', decimals: 1 },
            tail: { key: 'tailLength', decimals: 0 },
            count: { key: 'birdCount', decimals: 0, onChange: updateBoidCount },
            evasion: { key: 'evasionIntensity', decimals: 1 },
            panic: { key: 'panicFlockMultiplier', decimals: 1 }
        };

        // Hawk toggle
        document.getElementById('hawk-on').addEventListener('click', () => {
            config.hawkEnabled = true;
            hawk = new Hawk();
            document.getElementById('hawk-on').classList.add('active');
            document.getElementById('hawk-off').classList.remove('active');
        });

        document.getElementById('hawk-off').addEventListener('click', () => {
            config.hawkEnabled = false;
            hawk = null;
            document.getElementById('hawk-off').classList.add('active');
            document.getElementById('hawk-on').classList.remove('active');
        });

        function updateBoidCount() {
            while (boids.length < config.birdCount) {
                boids.push(new Boid());
            }
            while (boids.length > config.birdCount) {
                boids.pop();
            }
        }

        for (const [id, ctrl] of Object.entries(controls)) {
            const input = document.getElementById(id);
            const valueDisplay = document.getElementById(`${id}-value`);

            input.addEventListener('input', () => {
                const value = parseFloat(input.value);
                config[ctrl.key] = value;
                valueDisplay.textContent = value.toFixed(ctrl.decimals);
                if (ctrl.onChange) ctrl.onChange();
            });
        }

        // Mouse mode buttons
        document.querySelectorAll('.mouse-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.mouse-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                config.mouseMode = btn.dataset.mode;
            });
        });

        // Reset button
        document.getElementById('reset').addEventListener('click', () => {
            config.separationWeight = 1.5;
            config.alignmentWeight = 1.0;
            config.cohesionWeight = 1.0;
            config.neighborRadius = 50;
            config.maxSpeed = 4;
            config.tailLength = 10;
            config.birdCount = 100;
            config.mouseMode = 'off';
            config.hawkEnabled = false;
            config.evasionIntensity = 2.0;
            config.panicFlockMultiplier = 3.0;
            hawk = null;

            document.getElementById('separation').value = 1.5;
            document.getElementById('alignment').value = 1.0;
            document.getElementById('cohesion').value = 1.0;
            document.getElementById('radius').value = 50;
            document.getElementById('speed').value = 4;
            document.getElementById('tail').value = 10;
            document.getElementById('count').value = 100;
            document.getElementById('evasion').value = 2.0;
            document.getElementById('panic').value = 3.0;

            document.getElementById('separation-value').textContent = '1.5';
            document.getElementById('alignment-value').textContent = '1.0';
            document.getElementById('cohesion-value').textContent = '1.0';
            document.getElementById('radius-value').textContent = '50';
            document.getElementById('speed-value').textContent = '4';
            document.getElementById('tail-value').textContent = '10';
            document.getElementById('count-value').textContent = '100';
            document.getElementById('evasion-value').textContent = '2.0';
            document.getElementById('panic-value').textContent = '3.0';

            document.querySelectorAll('.mouse-mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('[data-mode="off"]').classList.add('active');
            document.getElementById('hawk-off').classList.add('active');
            document.getElementById('hawk-on').classList.remove('active');

            updateBoidCount();
        });

        // Randomize button
        document.getElementById('randomize').addEventListener('click', () => {
            for (const boid of boids) {
                boid.x = Math.random() * canvas.width;
                boid.y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * config.maxSpeed;
                boid.vx = Math.cos(angle) * speed;
                boid.vy = Math.sin(angle) * speed;
                boid.history = [];
            }
        });

        // Toggle panel
        const toggleBtn = document.getElementById('toggle-btn');
        const controlPanel = document.getElementById('controls');

        toggleBtn.addEventListener('click', () => {
            controlPanel.classList.toggle('collapsed');
            toggleBtn.classList.toggle('collapsed');
            toggleBtn.textContent = controlPanel.classList.contains('collapsed') ? 'Show' : 'Hide';
        });
    </script>
</body>
</html>
